[
["index.html", "R 資料科學與統計 Prerequisites", " R 資料科學與統計 Jeff Lin 2020-10-11 Prerequisites R 可視為統計數學軟體, 也是一種程式語言, 而近年來的發展, R 更成為資料科學的熱門的工具之一. R 是一個免費的統計分析軟體 (open-source, GNU General Public License), R 由一群跨國際的志工人員組成的 {R} 核心發展組織 (R core-development team) 所維持, 運作與持續更新發展. 目前對初學者的 R 入門學習有二大主要論點, 一為學習使用 R Base 原始語言與原始套件, 二為直接學習外部套件, 如 ggplot2, tidyverse 系統. 無論哪一種方式各有其優缺點. 個人認為對未來必須經常性使用 R 進行資料分析工作的初學者, 則建議先學習使用 R Base 原始語言. 對於未來僅在少數時間必須使用 R 進行資料分析工作, 或是僅在統計學上課使用, 則建議學習 ggplot2, tidyverse 等外部套件. 至於已經具有其他程式語言基礎, 則二者學習方式無多大差別. 作者個人對學習使用 R Base 原始語言與原始套件的介紹, 可參考 R 程式語言與醫學統計. 目前有許多 R 書籍, 寫作本書主要是為了個人上課方便使用, 假設讀者沒有太多統計資料分析概念或經驗, 也無程式語言寫作經驗. 本書的主要寫作對象為醫師或醫學研究人員, 以及使用 R 輔助學習統計的大學生為主. 本書使用 R bookdown package 寫作 (Xie 2020), 方便隨時更新內容. 本書前面章節資料使用醫學相關資料或是基礎統計學相關資料, 先降低資料的複雜性有助於了解 R 統計程式語言的核心, 後面章節再導入大數據分析. 本書關於 R base 多數摘取本人 R base 內容, R 程式語言與醫學統計, 後面章節主要介紹使用 ggplot2, tidyverse 系統套件進資料分析工作, 主要參考來源 https://r4ds.had.co.nz/ 與 https://rstudio-education.github.io/hopr/. 但學習歷程很難將二者完全切割, 通常會交錯並進. References "],
["intro.html", "Chapter 1 R 語言基本概論 1.1 下載與安裝 R 1.2 下載與安裝 RSudio 1.3 簡單實例 1.4 物件 Object 1.5 使用指令 1.6 查詢顯示物件與刪除物件 1.7 程式中止操作 1.8 工作目錄 1.9 程式編輯軟體與整合系統 RStudio 1.10 函式 Function 1.11 套件 Packages 1.12 解說與輔助文件 1.13 地區語系與時區", " Chapter 1 R 語言基本概論 R 系統是由 Ross Ihaka 與 Robert Gentleman 從 S 語言所發展出來, 主要是為了統計分析與統計繪圖. R 除了資料處理與分析, R 擁有一完整陣列和矩陣的操作運算, 完整圖形工具, 也是一種相當完善的程式設計語言. S 語言在 1980 年代末期, 由 AT&amp;T 實驗室, Rick Becker, John Chambers, 與 Allan Wilks 發展用來進行統計分析與統計繪圖, 1990 年代, Insightful 公司將 S 商品化, 並加入許多方便的操作介面, 稱為 Splus. R 與 S (或 Splus) 語法大多相近, R 與 S 都是以物件導向為主的程式語言, 透過交互作用方式很容易地進行統計分析與統計繪圖, 在當年 S 語言使用交互作用方式與當時主流統計軟體, 如 SAS, SPSS 有相當差異. 且最大差別是 R 是一個免費的統計分析軟體 (open-source, GNU General Public License), R 目前由一群跨國際的志工人員組成的 {R} 核心發展組織 (R core-development team) 所維持, 運作與持續更新發展, 在今日, {R} 不僅是統計專業人員的研究工具, 也是資料科學家經常使用的重要工具之一. 1.1 下載與安裝 R R 有各種版本, 可以在 Microsoft Window, Unix/Linux, Apple Mac OS 等作業性系統運行, 以下則以 windows 作業系統為主要說明. 若你的 windows 使用者名稱或帳號為中文, 請先進入控制台, 新增或變更 ``使用者名稱’’ (User), 更改使用者名稱為英文, 然後才進行以下安裝. 任何與 R 的檔案名稱或路徑名稱, 請勿使用中文, 空格或特殊符號. R 與其他軟體成可以形成強大的可重製性研究論文或動態文件 (Reproducible Research, Dynamic Documentation), 可同時依序安裝 Rtools, RStudio, Tex System, Pandoc, Git 等相關軟體. 初學者請請讓軟體內設的路徑 (PATH) 自動安裝, 不要任意更動 PATH 與安裝位置. 安裝任何與 R 相關軟體, 請按滑鼠右鍵以系統管理員身分執行. R 時常有更新版本, 下載與安裝 R 與 Rtools 簡述如下: 1. 上網至 http://www.r-project.org 2. 按滑鼠點選網頁左邊連結 (Link) 下載區 Download CRAN. 3. 按滑鼠點選網頁 CRAN Mirrors 中的任一鏡像網址 (CRAN Mirrors), 如 https://cloud.r-project.org/ 4. 按滑鼠點選上述鏡像網址內網頁中的 Download R for Windows. 5. 按滑鼠點選網頁 R for Windows 中的 base. 6. 按滑鼠右鍵, 點選檔案網址 Download R X.Y.Z for Windows, 其中 X.Y.Z 為 R 版本代碼, 下載儲存至個人檔案夾內. 7. 至下載的檔案夾內, 按滑鼠右鍵點擊 R-X.Y.Z-win.exe, 以系統管理員身分執行安裝. 8. 可選擇中文或英文進行安裝, 只要安裝 64 位元系統. 9. 回到與 base 同一網頁視窗, 點選 Rtools, 點選最先版本的 Rtoolsxx.exe. 下載檔案, 請按滑鼠右鍵以系統管理員身分執行安裝. 10. 詳細安裝 Windows, Mac 或 Linux 作業系統, 利用 google 或 Youtube 等, 搜尋相關訊息. 1.2 下載與安裝 RSudio 直接在 {R} 視窗輸入 {R} 指令並不是很方便. 使用文字編輯軟體輸入, 修正, 儲存, 然後再送到 {R} 執行. 過去有許多 {R} 文字/程式編輯軟體可用, RStudio 是目前最方便的 {R} 編輯程式, RStudio 原始是 {R} 的一種操作介面, 目前也衍伸成可使用多種程式語言的操作介面. 可上網至 http://www.rstudio.com/, 在 Product 選項下, 選擇 R premier IDE for R, 選擇 Rstudio Desktop, 選擇合適的作業系統進行下載 RStudio. 下載 Rstudio 檔案完成後, 請按滑鼠右鍵以系統管理員身分執行安裝. 再次注意, 使用者名稱 (User Name), 須更改使用者名稱為英文, 然後才進行下載安裝. 任何與 RSudio 的檔案名稱或路徑名稱, 請勿使用中文, 空格或特殊符號. 若想使用 Tex/LaTeX, 或 讓 Rstudio 產生 PDF 檔案, 需依序安裝 Tex system, Pandoc, Git, 安裝 TeX/LaTeX/XeLaTex 系統, 請至 https://www.latex-project.org/get/, 或直接安裝 MikTeX: http://miktex.org/. 安裝 Pandoc, 請至 http://pandoc.org/, 或 http://pandoc.org/installing.html. 安裝 Git, 請至 https://git-scm.com/. 同時申請 GitHub 帳號, 任何軟體請按滑鼠右鍵以系統管理員身分執行安裝. 詳細的可重製性研究論文操作, 可參考 (Xie 2015), Xie (2020) https://bookdown.org/yihui/rmarkdown/, https://rmarkdown.rstudio.com/ 等文件. 1.3 簡單實例 學習 {R} 最好的方法, 就是要開始使用 {R}, 初學者要了解 {R}, 可先進行一些簡單實例的演練, 首先須注意的是, 在 {R} 程式語言所使用的文字, 大小寫是有差別的. 直接在 {R} 或 RStudio console 視窗輸入指令都會得到相同的結果. 1 + 2 # calculator log(3.14) # log function x = 1 + 2 # one plus two assign to x x # print x x = c(1, 3, 5, 7) # get a vector mean(x) # mean function log(x) # log function 若要自學基本 {R} 或 進階 {R}, 利用 google 搜尋 R Introduction, R Tutorial 等, 或搜尋與觀看 YouTube 影片. 請繼續練習下列指令. factorial(4) sin(pi) x.vec &lt;- c(2:5) exp(x.vec) matrix(c(1:6), nrow = 2, ncol = 3) weight = c(50, 45, 67, 53) mean(weight) sd(weight) {R} 具有強大的繪圖功能, 可將程式語言與繪圖函數緊密結合, 控制標題, 顏色, 說明文字等, 繪製高品質的統計圖並可儲存於不同格式, 提供不同文書處裡軟體使用. 練習以下指令可以體會一些 {R} 的繪圖功能. ## demo demo(graphics) demo(image) example(contour) demo(persp) example(persp3d) demo(plotmath) demo(Hershey) install.packages(&quot;lattice&quot;) # install package library(&quot;lattice&quot;) # load package demo(lattice) example(wireframe) install.packages(&quot;rgl&quot;) library(&quot;rgl&quot;) demo(rgl) # Interact using your mouse. {R} 是統計程式語言, 程式語言是語言的一種, 程式語言是人與電腦溝通的工具, 任命令電腦做事的語言. 程式語言是須嚴謹的邏輯語法, 電腦才會正確執行命令, {R} 對於未有統計專業背景的初學者是困難學習的語言, 初學者學習 {R} 語言, 類似小孩學習語言, 通常須 0.5 – 1.0 年以上, 初學者請先直接學習現成實用的簡單指令, 初學者請不要先學太多抽像語法與閱讀抽像說明, 若已經學習其它一種程式語言相對較容學會易另一種程式語言. 學習程式語言最大挫折是城市經常出現無法理解的錯誤訊息, 可利用 google, 將錯誤訊息尋找容易理解的答案. {R} 最常犯的錯誤如下: 英文大小寫差異. 英文單字拚錯. 中文編碼問題, Big5 與 utf-8 等. 缺少標點符號: 單/雙引號, 逗號, $, }, ], ). 變數名/物件名, 指令, 資料檔案: 多餘空白, 多餘空格, 多餘 Tab 等. 直接從 PDF 文件 或 Web 等 copy 程式造成亂碼. 未詳細閱讀錯誤訊息或警告訊息. 初學者對物件命名時, 應盡量避免定義一個物件名字, 與現有的物件同名, 所以命名時要避免重覆, 同時避免物件名字過短, 以免後來引起錯亂. 1.4 物件 Object {R} 與 S 是物件導向為主的程式語言, (Object-Oriented Programming Language), 在 {R} 系統中, 儲存的資料或可執行的函數, 都稱為 物件 (object). {R} 物件包含儲存資料的 向量 (vector), 矩陣 (matrix), 陣列 (array), 列表 (Lists), 資料框架 (data frames) 或執行特定運算指令的 函式 (function) 等. {R} 透過函式或指令, 很容易地對資料物件進行統計分析與統計繪圖. 須特別注意, 在 {R} 對物件或指令命名的英文大小寫是有差異, s 與 S 是不同的. 對物件命名時, 物件名字 (object name) 起始位置必須以 英文字母 或 . (句點) 命名, 若物件名字以 . 為起始, 則物件名字的第二個位置需為文字, 物件名字其餘位置, 以英文字母 (A-Z 或 a-z), 數字 (0-9), /, ., _ (underscore) 或 -, 等皆可. 中間不可有空格. {R} 也保留一些特定名字做為特定的物件名字, 指令名字或常用函式名字使用, 例如, c, s, C, T, F 等, 這些名稱叫做 保留名字 (reserved names). 例如: FALSE Inf NA NaN NULL TRUE break else for function if in next repeat while F T c q s t C D I diff mean pi range rank var 初學者對物件命名時, 應盡量避免定義一個物件名字, 與現有的物件同名, 所以命名時要避免重覆, 同時避免物件名字過短, 以免後來引起錯亂. 1.5 使用指令 {R} 基本介面是一個互動式指令視窗, 指令可分成 2 種, 一為 運算式 (expression), 例如, 1 + 2 log(x) mean(x) 另一個為 指派運算 或 賦值運算 (assignment), 例如, x &lt;- 1 + 2 x = 4 - 5 當一個 {R} 程式需要使用者輸入指令時, 它會顯示 指令提示符號 (prompt symbol), 指令提示符號通常是一個 &gt; (大於符號). 當使用者輸入完整的 運算式, 則運算式指令輸入後的結果, {R} 會馬上顯示在指令下方. 當使用者輸入完整的 指派運算, {R} 同樣會做運算式, 並且把結果 (值) 傳給變數, 但結果不會自動顯示在 {R} 視窗螢幕上. 在 {R} 中可利用 options(prompt = &quot;R&gt;&quot;) 將指令提示符號 &gt; 改成 R&gt;. 指派運算符號 (assignment symbol) 通常是 &lt;- ``, 一個小於符號和一個短線符號組成, 例如,x &lt;- 1 + 2, 讀成x**得到** $(1 + 2)$. 在 {R} 中可以如傳統的程式語言或統計軟體, 使用=(等號) 為 **指派運算符號**, 例如,x = 1 + 2, 但在 {R} 中,=(等號) 還有其他用途, 使用者可依個人習慣使用&lt;-或=, 但是多數 {R} 專業人士建議使用&lt;-`. 要顯示賦值運算的結果, 可以輸入物件名, 使用函式 print(), 或在賦值運算時, 前後加上小括號顯示賦值運算的結果. ## asign x &lt;- 1 # assign object x x # show x ## [1] 1 print(x) # print() ## [1] 1 msg &lt;- &quot;hello&quot; msg # show x ## [1] &quot;hello&quot; 如果一條輸入的指令在第一行結束的時候, 在 {R} 語法上還不完整, 若用鍵盤上 &lt;Enter&gt; 按鍵時, 則 {R} 會給出另一個不同的提示符號, 通常是 + (加號), 且該提示符號 + 會出現在第二行, 和隨後的數行中, {R} 持續地等待使用者輸入指令. 當一指令在語法上是完整的時候, 使用鍵盤上 &lt;Enter&gt; 按鍵時, {R} 才會執行指令. 不同的完整指令要在同一行輸入時, 可用 ; (分號) 隔開, 或是另起一新輸入行輸入指令分別輸入不同的完整指令. 例如, ## input at the same line, use ; x &lt;- 1 + 2; y &lt;- 3 + 4 ## input 2 lines separately x &lt;- 1 + 2 y &lt;- 3 + 4 數個指令也可以放入一組大括弧內, { ; }, 數個指令放在一起, 構成一個 複合運算式 (compound expression), 這部份在函式的章節會再進一步說明. 在 {R} 中, 若要對任何指令, 物件, 程式語言 加上 注釋 (commands), 則注釋從 # (井號) 開始, 到句子收尾之間的語句就是是注釋, 在 {R} 中, 注釋幾乎可以放在任何地方的任何一行之中. 習慣上, 整行的注釋使用雙井號作為開始, ##, 運算式尾端注釋使用單井號開始 #. ## This is my R code log(pi) ## [1] 1.145 ## simple calculation 3+4 # calculator: two plus one ## [1] 7 在 {R} 互動式窗 Console 中, 若要重複一個指令, 或是叫回之前輸入的指令, 可以用鍵盤上的 \\(\\uparrow\\) (向上) 箭頭按鍵, 調出之前已經輸入的指令, 視窗中便可顯示之前的輸入指令, 再利用鍵盤上 &lt;DEL&gt; 按鍵更改成所要輸入的指令. 可以再次練習以下指令, 檢視 {R} 會傳結果. # This is my R code x = 1 + 2 # one plus two x ## [1] 3 x + 4 ## [1] 7 x - 1 ## [1] 2 1.6 查詢顯示物件與刪除物件 在 {R} 中產生和控制的實體稱為 物件 (object), 它們可以是向量, 陣列, 字串, 函式等不同型式. {R} 函式 object() 或 ls() 可以查詢與顯示當前保存在 {R} 環境中的物件名稱. ## show objects objects() # shiow all objects ls() # show all obkects ls(x, y) # show x and y object 透過函式 rm(), 可以刪除物件, 例如, ## delete objects: x.vec and y.vec rm(x.vec, y.vec) 可以刪除物件 x.vec 與 y.vec. 1.7 程式中止操作 當程式寫作不當, 造成 {R} 永無止境的執行運算. 若要中斷執行中的程式, 可按下 &lt;Esc&gt; 鍵中斷執行中的程式. 例如, 輸入 for (i in 1:1000000) print (i) # press &lt;Esc&gt; 按下 &lt;Esc&gt; 鍵可中斷執行中的程式. 1.8 工作目錄 任何 {R} 工作中產生的物件或暫時檔案, 都會在電腦的 工作目錄 或 工作路徑 (working directory). {R} 指令內的路徑 (PATH) 分隔為 // (例如, C://RData//) 或 / (例如, C:/RData/). 可用 Windowns 的 \\(\\backslash\\backslash\\) (例如, C:\\(\\backslash\\backslash\\)RData). 指令 getwd(), 可以顯示當前工作目錄. 指令 setwd(), 可以改變當前工作目錄. 請練習以下指令. getwd() # show your current working directory setwd(&quot;C:/RData/&quot;) getwd() ## [1] &quot;C:/RData&quot; 請再比較下列比較檔案路徑格式指令. setwd(&quot;C:/RData&quot;) getwd() setwd(&quot;C:/RData/&quot;) getwd() 使用 {R} 做統計資料分析, 不同的分析資料計畫, 最好使用不同的工作目錄, 以免相同名字的物件, 相互取代, 也便於管理. 在分析資料過程中, 將物件命名為 age, gender, m1.lm, m2.lm 等, 是一件常有的情形, 在任一次的分析計畫中, 這樣的命名是有其特定含義, 但不同分析資料計畫, 在一個工作目錄下進行時, 區別資料內相同物件名字, 是一件非常困難的事情. 此時可以利用 RStudio 專案計畫 (project), 將不同資料分析或課程內容獨立在一個專案計畫, 每一個專案計畫都在同一檔案路徑或檔案夾中, 此時程式便可攜帶任一作業系統或上傳到 GitHub 系統. 詳細的可重製性研究論文操作與版本控制 (version control), 可參考 (Xie 2015), Xie (2020) https://bookdown.org/yihui/rmarkdown/, https://rmarkdown.rstudio.com/, https://happygitwithr.com/ 等文件. 1.9 程式編輯軟體與整合系統 RStudio 若要方便使用中文以及可重製性研究論文系統, 可更動下列選項. 開啟 RStudio: 使用滑數點選 Tools, 點選 Global Options..... 點選 General, 取消點選 Restore .RData, 在 Save workspace to .RData on exit: 點選 Never. 在 Default text encoding: 點選 UTF-8. 點選進入 Appearance, 點選你喜歡的式樣, 例如, 點選 Zoom: 140%, 點選 Font size: 14, 點選你喜歡的字型. 點選進入 Sweave, 在 Waeve Rnw file using: 點選 knitr, 在 Typest LaTeX into PDF using: 點選XeLaTeX`. 最後記得點選 Apply 或 OK. 開始使用 {RStudio} 撰寫第一個 R 程式檔案. 開啟 {RStudio}, 檢視 {RStudio} 在左上角視窗最上端工具列. 點選 File \\(\\rightarrow\\) New File \\(\\rightarrow\\) R Script, 開啟一新的 R 程式檔案. 同樣在左上角視窗最上端工具列, 點選 File, \\(\\rightarrow\\) 存檔案 Save as, 在檔案夾 C:\\(\\backslash\\)RData, 儲存成為 Rlab00.r 檔案. 以 .r 或 .R 為副檔名, 代表 {R} 程式檔案. 在 source 視窗, 輸入以下程式. 輸入完成後, 同樣在左上角視窗最上端工具列, 點選 File, 存檔案 Save. 上述操作部分指令有捷徑可使用. 以下撰寫第一個 R 程式, 並完成存檔. ## Rlab00.r x &lt;- 1 print(x) x msg &lt;- &quot;hello&quot; msg y &lt;- 1:20 y rm(x, msg, y) 將程式輸入在 R 程式檔案內, 將要執行的程式行列, 以滑鼠反白, 複製 (copy) 到 {RSudio} Console 視窗, 執行程式. 可以滑鼠反白, 同時按 &lt;control&gt;+&lt;Enter&gt; 鍵, 執行程式. 使用 {R} 程式檔案, 可保有 {R} 程式, 隨時修正或重複執行. 將下列指令輸入在 {RStudio} 新建立的 Rlab00.r 檔案內. 請再次練習下列指令, 並執行致令, 在 {RSudio} Consol 視窗檢視結果. 開啟 {RStudio}, 檢視 {RStudio} 在左上角視窗最上端工具列. 點選 File \\(\\rightarrow\\) New File, 可嘗試建立 \\(\\rightarrow\\) R Notebook 或是 R Markdown, {RStudio} 會自動建立簡單模板 (template). 可見在區塊 (chunk) 以三個撇號 ```{r} 與尾端三個撇號 ``` 之間 可以撰寫 R 程式. 例如, ```{r} 2.4*3.8 x.vec = rnorm(50) y.vec = rnorm(50) plot(x.vec, y.vec) ``` 使用 R Notebook或是R Markdown的好處是可以將報告文字與統計分析結果, 表格或圖片整合, 不用再copy$\\rightarrow$paste到 word 文件上. 當資料增加或修正, 僅要按下上方knit, 即可再次自動排版產生正確的分析結果, 表格或圖片. 讀者可利用 R Notebook 或是 R Markdown 的模板, 按下上方 knit 檢視生成的報告. 1.10 函式 Function {R} 有許多 函式 (function), 函式是一種物件, 是指令的集合, 執行特定功能或運算工作的指令, 資料整理, 資料分析等, 透過函式, 擴展了 {R} 在程式語言的功能性與便利性. 函式內通常需輸入 引數 (argument). {R} 基本系統 (base) 提供了一部分常用函式, 而更多不同類型的函式, 則由許多不同的學者貢獻到 {R} 系統 (contribution) 中, 這些函數都是用 {R} 程式語言寫成的. 例如, 統計常用函式 mean(), var(), sd(), log() 等. 請練習以下 R 程式. ## function ## function c() = concatenate elements, return a vector x.vec x.vec = c(1:5) x.vec # show x.vec ## [1] 1 2 3 4 5 mean(x = x.vec) # function mean() calculate mean, return a scalar ## [1] 3 var(x = x.vec) # function mean() calculate variance ## [1] 2.5 log(x = x.vec) # take log for all elements in vector x.vec ## [1] 0.0000 0.6931 1.0986 1.3863 1.6094 一個函式內通常需輸入 引數 (argument) 或是 統計公式, 統計模型, (formals). 引數可以是一個以上, 有些引數一定要輸入, 稱為 必要引數 (required argument), 有些引數可以不用輸入, 稱為 自選引數 (optional argument), 另外一種引數則為 省略引數 (ellipsis argument) 這三種引可以同時存在一個函式內, 引數可以是數值, 文字, 資料框架或 {R} 的任何物件. 例如, 函式 log() 指令: log(x, base = exp(1)) log() 函式在 {R} 內設以自然數為底計算, 其中 x 為必備引數, 使用者必須自行輸入所要計算的數值作為引數值. 而 base = exp(1) 為選擇引數, 若使用者沒有輸入引數值, 函式 log() 內設以自然數 \\(e\\) 為底, 當然, 使用者可以更動底數的設定值, 例如更動為以 \\(2\\) 為底的獨度對數運算, log(x, base = 2). ## log function x.vec &lt;- c(1, 2, 3, 4, 5) log(x = x.vec) ## [1] 0.0000 0.6931 1.0986 1.3863 1.6094 log(x = x.vec, base = 2) ## [1] 0.000 1.000 1.585 2.000 2.322 1.11 套件 Packages 特定的統計分析方法許多專用的函式集合成一組. 套件 (package). 許多學者針對特定分析, 寫成專用的 {R} 函式, 學者常將這些特定的統計分析方法專用的函式集合成一組 套件 (package), 例如, survival 套件, 專用來進行存活分析, 例如, 在資料科學上大量使用 tidyverse 套件. {R} 的套件數目一直在快速增加, 個別套件內則有不同的函式. 在 {R} 中, 由一些標準 (基本) 套件構成 base {R}, 包含 {R} 可以進行一些標準統計和繪圖所需的的基本函數, 在任何 {R} 的安裝版本中, 都會被自動安裝與載入. 另外, 許多學者為 {R} 提供了基本套件以外的套件, 稱為 貢獻套件 (contributed package). 若在 {R} 第一次使用某一特定功能的套件, 則需事先安裝此特定套件. 安裝套件有不同的方法, 若已經先連接網際網路, 常用的方法為 (1) 使用 {RStudio} 內設套件所在的位置. 由 {RStudio} 右下套件視窗. 使用滑鼠選擇 Packages \\(\\rightarrow\\) Install. 輸入所要安裝的套件名稱, 例如, tidyverse, MASS 等. 使用函式 install.packages() 安裝所需的套件. install.packages(&quot;PackageName&quot;, dependencies = TRUE) 可以安裝 PackageName` 套件. 例如, 可將下列指令寫入 `Console 視窗內. install.packages(&quot;survival&quot;) library(survival) 若在 {R} 中, 要使用某一特定的套件, 須先載入此特定的套件, 請先確認已經安裝套件或更新套件. 使用 library() 或 require() 函式載入套件. 通常建議使用 library(), 因為 library() = loads a package, 會同時檢視套件與關聯的函式是否安裝妥當, 而 require() = tries to load a package, 且當套件與關聯的函式未安裝妥當時, 並不會提出警告或出現 error 訊息, 例如, 函式 foo() 在套件 paa 未先安裝或使用妥當, 使用 require() 納入套件 pbb, 套件 pbb 的函式 coo() 會呼叫 物件函式 foo(), 但使用者並未先納入套件 paa 執行套件 paa 其他程式不會提出警告, 但當使用者在後續使用到函式 coo() 時, 才會出現 error 訊息, 或是不出現 error 訊息而出現產生的物件, my.obj, 不存在, 因此很難追尋到錯誤來源. 通常在使用 library(package.name) 之後, 就可直接使用 package.name 套件內的函式 function.name(). 個別套件內有許多函式, 不同套件可能有相同名稱的函式, 若要避免誤用相同名稱的函式, 可以使用 {::} 串聯 package.name 與 function.name() 如下: package.name::function.name() 就可正確使用特定套件 package.name 內的特定函式 function.name(). 例如使用指令 ggplot2::ggplot() 明確指出使用套件 ggplot2 內的函式 ggplot(). 1.12 解說與輔助文件 {R} 有良好的解說文件, 可利用 Google 搜尋任何 {R} 相關疑惑. {R} 內部最常使用的線上協助為啟動網頁流覽器 help.start(). 嘗試在 Console 輸入 help.start() 尋找特定函式 funName 解說, 在 {R} 中可直接輸入下列任一種函式, help(funName), ?funName, help.search(\"funName\"), apropos(\"funName\") 等等. 例如, 尋找 函式 mean() 函式解說. 在 {R} 中可直接輸入下列任一種指令. help(mean) ?mean help.search(&quot;mean&quot;) apropos(&quot;mean&quot;) 若要詢問函式內的引數, 可用函式 args(\"funName\"). 1.13 地區語系與時區 {R} 程式版本經常更新, 且 {R} 一些貢獻套件也經常在 {R} 版本更新後無法運作, {R} 一些貢獻套件對地區語系與時區的呈現文字非常敏感, 因此在牽涉到不同時區的時間計算與轉換, 可注意使用中 {R} 的地區語系與時區. 函式 sessionInfo() 可以取得使用中 {R} 的所有資訊. sessionInfo() 從函式 version() 可以看見 {R} 版本 version[['version.string']], 從函式Sys.getlocale() 可以看見 {R} 目前設定地區語系為 LC_COLLATE=Chinese (Traditional)_Taiwan.950;LC_CTYPE=Chinese (Traditional)_Taiwan.950;LC_MONETARY=Chinese (Traditional)_Taiwan.950;LC_NUMERIC=C;LC_TIME=Chinese (Traditional)_Taiwan.950. 這是設定台灣地區使用 cp950 (big5) 編碼. 對一些套件可能無法正確顯式. 從函式Sys.timezone() 可以看見 {R} 目前設定時區為 Asia/Taipei. {R} 在台灣當地時間 (local time) 中文格式有時會出現 NA, 一些地區中文的介面對於如何呈現日期時間有時會出現錯誤, 若日期時間輸入輸出格式出現錯誤, 可先改正輸入輸出格式, 例如, 改用英文標準時間 Sys.setlocale(\"LC_TIME\", \"C\"), 如此改成 UTC 時區 (Universal Time, Coordinated). 或是使用 ISO 時間格式. 若要更動語系可使用 # 中文 -&gt; 英文 Sys.setlocale(&quot;LC_CTYPE&quot;, &quot;en_US.UTF-8&quot;) # system(&quot;defaults write org.R-project.R force.LANG en_US.UTF-8&quot;) # linux/mac # 英文 -&gt; 中文 Sys.setlocale(category = &quot;LC_ALL&quot;, locale = &quot;cht&quot;) # system(&quot;defaults write org.R-project.R force.LANG zh_TW.UTF-8&quot;) # linux/mac 上述方式暫時有效, 重新啟動 {R} 後此設定就會消失. References "],
["vector.html", "Chapter 2 向量 2.1 向量 2.2 向量基本資料類型 2.3 向量產生函式 c() 2.4 向量基本運算操作符號 2.5 向量基本算數操作 2.6 向量關係比較操作 2.7 向量邏輯操作 2.8 向量元素命名 2.9 向量下標與索引 Inxex 2.10 遺失值 (缺失值) Missing Values 2.11 因子物件與類別變數 Factor", " Chapter 2 向量 {R} 是以物件導向為主的程式語言, 在 {R} 中, 資料或運算指令以具有名稱的 物件 (object), 形式儲存, 資料物件可以是 向量 (vector), 矩陣 (matrix), 陣列 (array), 列表 (Lists), 或 資料框架 (data frames) 等. 在 {R} 中, 資料分析基本上是產生資料物件, 對物件命名, 使用函式對物件運算操作. 透過指令, 很容易地對物件進行統計分析與統計繪圖. {R} 的資料結構與程式寫作相對於目前當紅的其他程式語言較多嚴謹的要求, 本章主要說明 {R} 的基本資料型式與基本運算. 2.1 向量 {R} 的最基本物件是向量, 向量 (vector) 是指包含相同 模式 (mode) 的元素組成. {R} 的基本資料型式稱為 基本模式 (basic mode) 有 numeric, integer, logical, complex, character. 同一向量內的元素不可混合. 單一數值 (scalar), 可視為僅具有單一元素的向量, 標準的向量是 倍精準度 (double) 的 數值向量 (numerical vector). 向量是具有相同基本類型的元素序列, 在 {R} 中, 純量或單一數值 (scalar) 也可看成是長度為 \\(1\\) 的向量, 向量大體上相當於其他程式語言中的 \\(1\\)-維度數列, 但在 {R} 中向量並不具有 沒有維度 (no dimension). 例如, 在 {R} 中 x.vec &lt;- c(1, 2, 3), 可以視為 \\(1 \\times 3\\) 的矩陣, 也可以視為 \\(3 \\times 1\\) 的矩陣, 但是, 當向量 x.vec 與其它向量/矩陣進行運算時, 向量 x.vec 會受到與其進行運算的矩陣物件影響, 若任由 {R} 的內在設定, 則常會有意想不到的運算結果. 2.2 向量基本資料類型 {R} 的最基本物件是向量, 向量 是指包含相同 模式 (mode) 的元素組成. {R} 的基本資料型式稱為 基本模式 (basic mode) 有 numeric, integer, logical, complex, character, 使用函式 class() 可以檢視基本模式. numeric, 數值型 (實數型), 含 single 單精準度型與 double 倍精準度型. # numeric x1 &lt;- 10.1 x1 ## [1] 10.1 class(x1) ## [1] &quot;numeric&quot; x2 &lt;- 10 x2 ## [1] 10 class(x2) ## [1] &quot;numeric&quot; is.numeric(x2) ## [1] TRUE integer, 整數向量 (有時需特別指定輸入成 1L, 2L, …). # integer y1 &lt;- 1L y1 ## [1] 1 class(y1) ## [1] &quot;integer&quot; is.integer(y1) ## [1] TRUE is.numeric(y1) ## [1] TRUE logical, 邏輯型或布林型 (true or false), 以 TRUE (T) 或 FALSE (F) 呈現, 也可以是 \\(1\\) 與 \\(0\\) 整數分別代表 T 與 F. # logic yes_id &lt;- TRUE yes_id ## [1] TRUE no_id &lt;- FALSE no_id ## [1] FALSE class(no_id) ## [1] &quot;logical&quot; is.logical(no_id) ## [1] TRUE 2 == 3 ## [1] FALSE 2 != 3 ## [1] TRUE 2 &gt; 3 ## [1] FALSE 2 &lt;= 3 ## [1] TRUE 4 &gt;= 1 ## [1] TRUE TRUE + 5 ## [1] 6 TRUE * 5 ## [1] 5 FALSE * 5 ## [1] 0 TRUE + FALSE ## [1] 1 TRUE * FALSE ## [1] 0 complex, 複數型. x = 3+5i x ## [1] 3+5i class(x) ## [1] &quot;complex&quot; character, 文字型或字串型, 通常輸入時在文字兩側加上雙引號 (\"). # character ca &lt;- &quot;yes&quot; ca ## [1] &quot;yes&quot; cb &lt;- &quot;this is a book.&quot; cb ## [1] &quot;this is a book.&quot; class(cb) ## [1] &quot;character&quot; is.character(cb) ## [1] TRUE &quot;abc&quot; &gt; &quot;abd&quot; ## [1] FALSE &quot;date&quot; &lt; &quot;dates&quot; ## [1] TRUE 資料分析另外常見的日期與類別變數也必須特別處裡. 格式有 Date, POSIXct 與 POSIXt等, 例如, 使用函式 Sys.Date() 可得系統日期. Sys.Date() ## [1] &quot;2020-10-11&quot; date1 &lt;- as.Date(&quot;2020-09-17&quot;) date1 ## [1] &quot;2020-09-17&quot; class(date1) ## [1] &quot;Date&quot; as.numeric(date1) ## [1] 18522 date2 &lt;- as.POSIXct(&quot;2020-09-17 18:30&quot;) class(date2) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; as.numeric(date2) ## [1] 1.6e+09 詳細的日期與類別變數操作, 以後再詳述. 2.3 向量產生函式 c() 輸入簡單的向量資料, 可以用函式 c() 指令. c()為 concatenate (連接), 將數值或文字連接成向量. ## c() ## numerical x.vec &lt;- c(1/1, 1/2, 1/3, 1/4, 1/5) x.vec ## [1] 1.0000 0.5000 0.3333 0.2500 0.2000 ## integer x.vec &lt;- c(1L, 2L, 3L) x.vec ## [1] 1 2 3 ## character flavors.vec &lt;- c(&quot;chocolate&quot;, &quot;vanilla&quot;, &quot;strawberry&quot;) # character flavors.vec ## [1] &quot;chocolate&quot; &quot;vanilla&quot; &quot;strawberry&quot; y.vec &lt;- c(&quot;Hello&quot;, &quot;What&#39;s your name?&quot;, &quot;Your email?&quot;) y.vec ## [1] &quot;Hello&quot; &quot;What&#39;s your name?&quot; &quot;Your email?&quot; ## logical z.vec &lt;- c(F, T, T, F, F) z.vec ## [1] FALSE TRUE TRUE FALSE FALSE ## complex x.complex.vec &lt;- c(8+3i, 9+0i, 2+4i) x.complex.vec ## [1] 8+3i 9+0i 2+4i ## numerical x.vec &lt;- c(1/1, 1/2, 1/3, 1/4, 1/5) y.vec &lt;- c(1, 2, 3, 4, 5) z.vec &lt;- c(x.vec, 11, 12, y.vec) z.vec ## [1] 1.0000 0.5000 0.3333 0.2500 0.2000 11.0000 12.0000 1.0000 2.0000 ## [10] 3.0000 4.0000 5.0000 2.4 向量基本運算操作符號 {R} 對物件運算操作有其 基本操作符號 (basic operators), 如同 C 語言, 可以分成算數操作 (arithmetic operator), 相關比較操作 (relation/comparison operator), 邏輯操作 (logical operator). {R} 也是一種高階程式語言 (programming language), 因此提供了其它程序語言共有的 條件 (if-else), 轉換 (switch), 迴圈 (loop) 與 函式 (function) 等, 程序控制結構語法, 進階資料分析使用高階程式語言與函式寫作進行. 本章先討論基本運算操作. 向量基本運算操作符號 符號 定義 - 減法運算 (Substraction, can be unary or binary) + 加法運算 (Addition, can be unary or binary) ! 否定運算 (Unary not) * 乘法運算 (Multiplication, binary) / 除法運算 (Division, binary) ^ 指數乘冪運算 (Exponentiation, binary) %% 整數除法的餘數 (Modulus, binary) %/% 整數除法的商數 (Integer divide, binary) %*% 矩陣內積乘法 (Matrix product, binary) %o% 矩陣外積乘法 (Outer product, binary) %x% 矩陣 Kronecker 乘法 (Kronecker product, binary) %in% 配對運算 (Matching operator, binary, in model formulae: nesting) &lt; 小於 Less than, binary &gt; 大於 Greater than, binary == 相等 Equal to, binary != 不相等 Not equal to &gt;= 大於或等於 Greater than or equal to, binary &lt;= 小於或等於 Less than or equal to, binary &amp; 邏輯 和, 向量的個別元素使用 (Logical AND, binary, vectorized) &amp;&amp; 邏輯 和, 二元操作 (Logical AND, binary, not vectorized) | 邏輯 或, 向量的個別元素使用 (Logical OR, binary, vectorized) || 邏輯 或, 二元操作 (Logical OR, binary, not vectorized) xor 邏輯 互斥, 向量個別元素互斥聯集運算, 僅有 1 為 TRUE 2.5 向量基本算數操作 {R} 向量物件的 算數操作 (arithmetic operator) 符號包含以下符號, +, -, !, *, /, \\^, %%, %/%, %*%, %o%, %x%, %in% 等 算數操作根據最基本的運算次序: 括號, 指數, 乘法, 除法, 加減法, 也就是如同一般手寫計算. ## Arithmetic Operator 1 + 2 ## [1] 3 1 + 2 + 3 ## [1] 6 3 * 7 * 2 ## [1] 42 4/2 ## [1] 2 4/3 ## [1] 1.333 2 * 3 + 4 ## [1] 10 2 * (3 + 4) ## [1] 14 (3 + 11 * 2)/4 ## [1] 6.25 # x.complex &lt;- (8+3i)+(1+2i) x.complex ## [1] 9+5i # x.vec &lt;- 1:5 y.vec &lt;- c(-1, -2, 0, 2, 4) z.vec &lt;- c(2, 2, 3, 3, 4) x.vec + y.vec ## [1] 0 0 3 6 9 x.vec - y.vec ## [1] 2 4 3 2 1 # x.vec * 2 ## [1] 2 4 6 8 10 x.vec * y.vec ## [1] -1 -4 0 8 20 x.vec/2 ## [1] 0.5 1.0 1.5 2.0 2.5 x.vec/y.vec ## [1] -1.00 -1.00 Inf 2.00 1.25 # x.vec^2 ## [1] 1 4 9 16 25 x.vec^z.vec ## [1] 1 4 27 64 625 y.vec/2 ## [1] -0.5 -1.0 0.0 1.0 2.0 y.vec/x.vec ## [1] -1.0 -1.0 0.0 0.5 0.8 # y.vec %% 3 # modular arithmetic remainder ## [1] 2 1 0 2 1 y.vec %/% 3 # integer division ## [1] -1 -1 0 0 1 y.vec %/% x.vec ## [1] -1 -1 0 0 0 2.6 向量關係比較操作 邏輯向量 (logic vector) 的元素值有 TRUE, FALSE. 可以分別簡寫為 T 和 F. 在 {R} 之內, 向量之間的 關係比較操作 (relation/comparison operator) 可以產生邏輯向量. 關係比較操作符號包含常見的 &lt;, &lt;=, &gt;, &gt;=. ## Relation/Comparison Operator x.vec &lt;- 1:5 y.vec &lt;- (x.vec &gt; 2) y.vec ## [1] FALSE FALSE TRUE TRUE TRUE any(x.vec &gt; 2) ## [1] TRUE all(x.vec &gt; 2) ## [1] FALSE # x.vec &lt;- 1:5 y.vec &lt;- c(0, 2, 4, 6, 8) # x.vec &lt; 2 ## [1] TRUE FALSE FALSE FALSE FALSE x.vec &lt;= 2 ## [1] TRUE TRUE FALSE FALSE FALSE x.vec == 2 ## [1] FALSE TRUE FALSE FALSE FALSE x.vec != 2 ## [1] TRUE FALSE TRUE TRUE TRUE # x.vec &lt; y.vec ## [1] FALSE FALSE TRUE TRUE TRUE x.vec &lt; (y.vec - 2) ## [1] FALSE FALSE FALSE FALSE TRUE x.vec &lt;= y.vec ## [1] FALSE TRUE TRUE TRUE TRUE x.vec &lt;= (y.vec - 2) ## [1] FALSE FALSE FALSE TRUE TRUE # x.vec == y.vec ## [1] FALSE TRUE FALSE FALSE FALSE x.vec == (y.vec - 2) ## [1] FALSE FALSE FALSE TRUE FALSE x.vec != y.vec ## [1] TRUE FALSE TRUE TRUE TRUE x.vec != (y.vec - 2) ## [1] TRUE TRUE TRUE FALSE TRUE 2.7 向量邏輯操作 在 {R} 之內, 向量之間的 關係比較操作 可以產生邏輯向量. 在 {R} 中可對邏輯向量進行運算操作, 邏輯操作 (logical operator) 符號包含常見的 ! (否定), &amp;, &amp;&amp; (AND), | , || (OR), 以及判斷相等的 == 和判斷不等的 != 等. ## Logical Operator: AND OR XOR x.vec &lt;- 1:5 y.vec &lt;- c(0, 2, 4, 6, 8) (x.vec &gt; 0) &amp; (y.vec &gt; 0) # return vector AND ## [1] FALSE TRUE TRUE TRUE TRUE (x.vec &gt; 0) &amp;&amp; (y.vec &gt; 0) # return scalar AND ## [1] FALSE # (x.vec &gt; 0) &amp; ((y.vec - 3) &gt; 0) # return vector AND ## [1] FALSE FALSE TRUE TRUE TRUE ((x.vec-2) &gt; 0) &amp;&amp; ((y.vec - 3) &gt; 0) # return scalar AND ## [1] FALSE # (x.vec &gt; 0) &amp; ((y.vec + 3) &gt; 0) # return vector AND ## [1] TRUE TRUE TRUE TRUE TRUE ((x.vec-2) &gt; 0) &amp;&amp; ((y.vec + 3) &gt; 0) # return scalar AND ## [1] FALSE # (x.vec &gt; 0) | (y.vec &gt; 0) # return vector OR ## [1] TRUE TRUE TRUE TRUE TRUE ((x.vec- 2) &gt; 0) | ((y.vec - 3) &gt; 0) ## [1] FALSE FALSE TRUE TRUE TRUE # (x.vec &gt; 0) || (y.vec &gt; 0) # return scalar OR ## [1] TRUE ((x.vec-2) &gt; 0) || ((y.vec - 3) &gt; 0) ## [1] FALSE # (x.vec &gt; 0) || ((y.vec + 3) &gt; 0) # return scalar OR ## [1] TRUE ((x.vec-2) &gt; 0) || ((y.vec + 3) &gt; 0) ## [1] TRUE # xor((x.vec &gt; 0), (y.vec &gt; 0)) # return vector exclusive OR ## [1] TRUE FALSE FALSE FALSE FALSE xor(((x.vec - 2) &gt; 0), ((y.vec - 3) &gt; 0)) ## [1] FALSE FALSE FALSE FALSE FALSE xor(((x.vec - 2) &gt; 0), ((y.vec + 3) &gt; 0)) ## [1] TRUE TRUE FALSE FALSE FALSE # xx.vec &lt;- (x.vec &lt;= 3) yy.vec &lt;- (y.vec &gt;= 4) xx.vec ## [1] TRUE TRUE TRUE FALSE FALSE yy.vec ## [1] FALSE FALSE TRUE TRUE TRUE # xx.vec &amp;&amp; yy.vec ## [1] FALSE xx.vec &amp; yy.vec ## [1] FALSE FALSE TRUE FALSE FALSE xx.vec || yy.vec ## [1] TRUE xx.vec | yy.vec ## [1] TRUE TRUE TRUE TRUE TRUE xor(xx.vec, yy.vec) ## [1] TRUE TRUE FALSE TRUE TRUE 2.8 向量元素命名 向量的每個元素或部分元素都可以命名, 使用者可以在輸入元素時直接給予命名, 或另外使用函式 names() 給予命名. 若要移除命名, 使用函式 unname() 移除命名, 或使用 names(x.vec) &lt;- NULL 移除命名. ## vector names x.vec &lt;- c( age = 50, chol = 220, dbp = 84, sbp = 132 ) # directly x.vec ## age chol dbp sbp ## 50 220 84 132 names(x.vec) ## [1] &quot;age&quot; &quot;chol&quot; &quot;dbp&quot; &quot;sbp&quot; # x.vec &lt;- c(55, 236, 80, 140) names(x.vec) &lt;- c(&quot;age&quot;, &quot;chol&quot;, &quot;sbp&quot;, &quot;dbp&quot;) # y.vec.name &lt;- names(x.vec) y.vec &lt;- c(60, 214, 90, 144) names(y.vec) &lt;- y.vec.name y.vec ## age chol sbp dbp ## 60 214 90 144 2.9 向量下標與索引 Inxex 一個向量的長度 (length) 是向量元素的數目, 一個向量的個別元素或部分元素可以向量的下標 (index) 取得, 向量的 下標 或 索引 (index) 是在向量名稱後面加 中括號 [i], 並放入下標數目 (或向量) 得到. 原始向量的下標可以採用下列四種方式的任何一種, 正整數, 負整數, 文字或字串與邏輯向量. ## Vector Indexing ## positive integer x.vec &lt;- 1:50 x.vec[7] ## [1] 7 x.vec[11:15] ## [1] 11 12 13 14 15 y.vec &lt;- x.vec[11:15] y.vec ## [1] 11 12 13 14 15 ## negative integer z.vec &lt;- 6:10 z.vec[-c(2, 4)] ## [1] 6 8 10 ## character string fruit.vec &lt;- c(5, 10, 1, 20) fruit.vec ## [1] 5 10 1 20 names(fruit.vec) &lt;- c(&quot;orange&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;peach&quot;) fruit.vec ## orange banana apple peach ## 5 10 1 20 lunch.vec &lt;- fruit.vec[c(&quot;apple&quot;, &quot;orange&quot;)] lunch.vec ## apple orange ## 1 5 ## logical index x.vec &lt;- c(NA, -2, -1, NA, 1, 2, NA) # NA = missing value x.vec ## [1] NA -2 -1 NA 1 2 NA y.vec &lt;- x.vec[!is.na(x.vec)] # !is.na() = check missing value y.vec ## [1] -2 -1 1 2 z.vec &lt;- x.vec[x.vec &gt; 0 &amp; !is.na(x.vec)] z.vec ## [1] 1 2 x.vec[x.vec &lt; 0] # Note: NA ## [1] NA -2 -1 NA NA y.vec[y.vec &lt; 0] ## [1] -2 -1 z.vec[z.vec &lt; 0] ## numeric(0) 2.10 遺失值 (缺失值) Missing Values 研究資料, 通常會有 遺失值 或 缺失值 (missing value, incomplete data**), 在 R 中, 輸入或輸出遺失值, 通常以 NA 表示, (NA = Not Available), R 還有另外有 NaN = Not a Number 是指物件運算後產生非數值結果, 以及 NULL 是指物件的長度是 \\(0\\). 任何對遺失值 (NA) 的算數操作, 會得到遺失值 (NA) 結果. 使用函式 is.na(), is.nan() 可以查看向量內那些元素是遺失值. 回傳一個邏輯向量. 對遺失值作比較大小運算須非常小心. 要移除遺失值, 可以使用函式 na.omit(), na.fail(), na.exclude(), na.action() 等指令. 且函式 complete.cases() 可以同時移出多個缺失值. 對於不同基本模式的向量元素進行融合, 若不合階層結構, 則 R 回傳缺失值. ## missing value z.vec &lt;- c(1:2, NA) is.na(z.vec) ## [1] FALSE FALSE TRUE log(z.vec) ## [1] 0.0000 0.6931 NA z.vec / 0 ## [1] Inf Inf NA 0 / 0 ## [1] NaN Inf - Inf ## [1] NaN # is.na(z.vec) ## [1] FALSE FALSE TRUE is.nan(z.vec) ## [1] FALSE FALSE FALSE is.nan(0 / 0) ## [1] TRUE is.na(0 / 0) ## [1] TRUE # x.vec &lt;- c(1, 2, NA, 4, NA, 5, 6) bad &lt;- is.na(x.vec) x.vec[!bad] ## [1] 1 2 4 5 6 complete.cases(x.vec) ## [1] TRUE TRUE FALSE TRUE FALSE TRUE TRUE x.vec[complete.cases(x.vec)] ## [1] 1 2 4 5 6 # x.vec &lt;- c(1, 2, NA, 4, NA, 5, 6) y.vec &lt;- c(&quot;a&quot;, &quot;b&quot;, NA, &quot;d&quot;, NA, &quot;f&quot;, &quot;g&quot;) good &lt;- complete.cases(x.vec, y.vec) good ## [1] TRUE TRUE FALSE TRUE FALSE TRUE TRUE x.vec[good] ## [1] 1 2 4 5 6 y.vec[good] ## [1] &quot;a&quot; &quot;b&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; x.vec &lt;- c(1, 2, 3, NA, NA, 5, 6) y.vec &lt;- c(&quot;a&quot;, &quot;b&quot;, NA, &quot;d&quot;, NA, &quot;f&quot;, &quot;g&quot;) good &lt;- complete.cases(x.vec, y.vec) good ## [1] TRUE TRUE FALSE FALSE FALSE TRUE TRUE # data(airquality) airquality[1:6, ] ## Ozone Solar.R Wind Temp Month Day ## 1 41 190 7.4 67 5 1 ## 2 36 118 8.0 72 5 2 ## 3 12 149 12.6 74 5 3 ## 4 18 313 11.5 62 5 4 ## 5 NA NA 14.3 56 5 5 ## 6 28 NA 14.9 66 5 6 good &lt;- complete.cases(airquality) airquality[good,][1:6, ] ## Ozone Solar.R Wind Temp Month Day ## 1 41 190 7.4 67 5 1 ## 2 36 118 8.0 72 5 2 ## 3 12 149 12.6 74 5 3 ## 4 18 313 11.5 62 5 4 ## 7 23 299 8.6 65 5 7 ## 8 19 99 13.8 59 5 8 2.11 因子物件與類別變數 Factor 因子物件 (factor) 為處理 類別資料 (categorical data), 提供的一種有效的方法. 類別變數 將變數值分成互斥的類別水準, 在類別變數定義中的特定幾種類別水準是否有大小差距, 又可分類成 名目變數 (nominal variable) 與 有序變數 (ordinal variable), 或稱 名目尺度 與 順序尺度. 其中 名目尺度 是最簡單的測量, 名目尺度將變數值分成互斥的類別水準, 同一變數內的類別水準並無量化大小的差別. 名目尺度用文字或數字表示或標記, 這些數字本身並無任何意義, 例如 左側為 1, 右側為 0; 1 = 拇指, 2 = 食指, 3 = 中指, 4 = 無名指, 5 = 小指. 在名目尺度中, 特別的情形是變數內只有 2 個類別水準, 如存活或死亡, 統計習慣上會分別標記為 0 或 1, 感染或無感染, 這類變數常稱做 二元變數 (dichotomous variable, binary variable), 二元變數通常有特殊的統計分析方法. 順序尺度 是指同一變數內的類別水準有 輕重, 大小, 強弱, 好壞等級順序之資料. 例如, 疼痛情形有 4 種情境: 無, 輕度, 中度, 重度, 癌症分期為 I, II, III, IV 等 4 期. 雖然順序尺度用數字 \\(1, 2, 3, 4, \\ldots\\) 表示或標記, 但是數字本身通常不能用來做運算, 只能比較相對大小或高低次序, 順序之間的實際差異並無法從標記的數字差異得知. 統計中的類別資料, 有各種不同表示方法, 在電腦的資料儲存時常常是以文字為變數值, 但使用上文字較占空間且無法精準傳達 類別變數的概念. 因此在 {R} 中特別使用 因子 (factor) 來表示. 因子是一種特殊的文字向量, 文字向量中的每一個元素, 取一個離散值, 因子物件 有一個特殊屬性, 稱為 層次, 水平, 水準 或 類別水準 (levels), 表示這組所有可能的離散值. 因子常常是用文字或字串輸入, 有時會使用數值或整數代表, 一但變數設定為因素或因子向量, {R} 在列印或輸出時, 並不會加上雙引號 \", 且數值或有大小順序的文字, {R} 在統計分析上都必須特別處理. 在 {R} 中若要設定因子, 可以簡單地用函式 factor() 產生無序因子物件. factor(x = character(), levels, labels = levels, exclude = NA, ordered = is.ordered(x), nmax = NA) 其中引數為 x 為原始向量, 通常為文字向量, 若是數值向量, {R} 先轉換成文字向量. levels 設定類別水準. labels 類別水準的標記文字. exclude = NA 排除缺失值或某一特定值為一類別水準. ordered = is.ordered(x) 設定因子物件類別水準的順序, 仍是無序因子物件. nmax = NA 是否類別水準的最大數目. ## factor() sex &lt;- c(&quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;male&quot;, &quot;female&quot;) sex ## [1] &quot;male&quot; &quot;female&quot; &quot;male&quot; &quot;male&quot; &quot;female&quot; class(sex) ## [1] &quot;character&quot; sex &lt;- factor(sex) sex ## [1] male female male male female ## Levels: female male class(sex) ## [1] &quot;factor&quot; ## factor() + levels sex &lt;- c(&quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;male&quot;, &quot;female&quot;) sex &lt;- factor(sex, levels = c(&quot;female&quot;, &quot;male&quot;)) sex ## [1] male female male male female ## Levels: female male ## factor() + levels + labels x.chr = c(&quot;male&quot;, &quot;male&quot;, &quot;female&quot;, &quot;female&quot;) factor(x.chr, levels = c(&quot;male&quot;, &quot;female&quot;, &quot;bisex&quot;)) ## [1] male male female female ## Levels: male female bisex factor(x.chr, levels = c(&quot;male&quot;, &quot;female&quot;, &quot;bisex&quot;), labels = c(&quot;m&quot;, &quot;f&quot;, &quot;b&quot;)) ## [1] m m f f ## Levels: m f b ## factor() + exclude ## factor() + exclude pain &lt;- c(&quot;none&quot;, &quot;mild&quot;, &quot;moderate&quot;, &quot;severe&quot;, NA) factor(pain) # NA is NOT a level. ## [1] none mild moderate severe &lt;NA&gt; ## Levels: mild moderate none severe factor(pain, exclude = NA) # NA is NOT a level. ## [1] none mild moderate severe &lt;NA&gt; ## Levels: mild moderate none severe factor(pain, exclude = c(NA)) # NA is NOT a level. ## [1] none mild moderate severe &lt;NA&gt; ## Levels: mild moderate none severe factor(pain, exclude = NULL) # NA is a level. ## [1] none mild moderate severe &lt;NA&gt; ## Levels: mild moderate none severe &lt;NA&gt; factor(pain, exclude = &quot;mild&quot;) # NA is a level. ## [1] none &lt;NA&gt; moderate severe &lt;NA&gt; ## Levels: moderate none severe &lt;NA&gt; pain &lt;- factor(pain, exclude = c(&quot;mild&quot;, NA)) pain # mild and NA are NOT levels. ## [1] none &lt;NA&gt; moderate severe &lt;NA&gt; ## Levels: moderate none severe {R} 中的 factor() 為 無序因子 (unordered factor), 類似於統計分析中的 名目變數 (nominal variable), 無序因子 中的類別水準 (level), 其離散值無大小順序的關係, 如性別的男與女. {R} 列印無序因子物件時, 類別水準 內建型式依照文字字母順序, 可以使用函式 levels() 查看無序因子物件的類別水準; 也可以使用函式 levels() 設定列印無序因子物件 類別水準 的顯示次序, {R} 內建顯示次序是依照文字字母或數字排次序, 可以使用函式 levels() 指令, 改變顯示因子物件的次序或方向. 在統計模型中常使用 類別變數 作為解釋變數, 常常必須令 無序因子物件 或 類別變數 的某一個類別水準為 參照水準 (reference level), 以便建構類別型解釋變數內不同類別水準的 對照比較 (contrast comparison). 使用函式 relevel(), 可以改變無序因子類別水準的參考水準. ## unorder ## level() gender &lt;- c(&quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;, &quot;F&quot;) gender &lt;- factor(gender) gender ## [1] M F M M F ## Levels: F M levels(gender) ## [1] &quot;F&quot; &quot;M&quot; levels(gender) &lt;- c(&quot;Female&quot;, &quot;Male&quot;) gender ## [1] Male Female Male Male Female ## Levels: Female Male hypertension &lt;- c(&quot;Lo&quot;, &quot;Mod&quot;, &quot;Hi&quot;, &quot;Mod&quot;, &quot;Lo&quot;, &quot;Hi&quot;, &quot;Lo&quot;) hypertension &lt;- factor(hypertension) hypertension ## [1] Lo Mod Hi Mod Lo Hi Lo ## Levels: Hi Lo Mod # relevel() relevel(hypertension, ref = &quot;Lo&quot;) # reset a reference level ## [1] Lo Mod Hi Mod Lo Hi Lo ## Levels: Lo Hi Mod ## correct hypertension &lt;- c(&quot;Lo&quot;, &quot;Mod&quot;, &quot;Hi&quot;, &quot;Mod&quot;, &quot;Lo&quot;, &quot;Hi&quot;, &quot;Lo&quot;) hypertension &lt;- factor(hypertension, levels = c(&quot;Lo&quot;, &quot;Mod&quot;, &quot;Hi&quot;)) hypertension ## [1] Lo Mod Hi Mod Lo Hi Lo ## Levels: Lo Mod Hi ## error, we will see the correct method later hypertension &lt;- c(&quot;Lo&quot;, &quot;Mod&quot;, &quot;Hi&quot;, &quot;Mod&quot;, &quot;Lo&quot;, &quot;Hi&quot;, &quot;Lo&quot;) hypertension &lt;- factor(hypertension) levels(hypertension) &lt;- c(&quot;Lo&quot;, &quot;Mod&quot;, &quot;Hi&quot;) hypertension ## [1] Mod Hi Lo Hi Mod Lo Mod ## Levels: Lo Mod Hi 使用 as.integer() 可將類別變數轉換成數值整數, 此數值整數從 1 到 類別水準的整數, 且依照原有的類別水準依序給整數, 使用上必須注意此差異. ## convert to numerical values hypertension &lt;- c(&quot;Lo&quot;, &quot;Mod&quot;, &quot;Hi&quot;, &quot;Mod&quot;, &quot;Lo&quot;, &quot;Hi&quot;, &quot;Lo&quot;) hypertension &lt;- factor(hypertension) levels(hypertension) ## [1] &quot;Hi&quot; &quot;Lo&quot; &quot;Mod&quot; hypertension ## [1] Lo Mod Hi Mod Lo Hi Lo ## Levels: Hi Lo Mod as.integer(hypertension) ## [1] 2 3 1 3 2 1 2 # levels(hypertension) &lt;- list(&quot;Low&quot; = &quot;Lo&quot;, &quot;Moderate&quot; = &quot;Mod&quot;, &quot;High&quot; = &quot;Hi&quot;) hypertension ## [1] Low Moderate High Moderate Low High Low ## Levels: Low Moderate High as.integer(hypertension) ## [1] 1 2 3 2 1 3 1 # ## convert to numerical values pain &lt;- c(7, 8, 6, 6, 8, 7) pain &lt;- factor(pain) pain ## [1] 7 8 6 6 8 7 ## Levels: 6 7 8 as.integer(pain) ## [1] 2 3 1 1 3 2 pain.chr = as.character(pain) pain.chr ## [1] &quot;7&quot; &quot;8&quot; &quot;6&quot; &quot;6&quot; &quot;8&quot; &quot;7&quot; pain.num = as.integer(pain.chr) pain.num ## [1] 7 8 6 6 8 7 We describe our methods in this chapter. "],
["dataobject.html", "Chapter 3 資料物件 3.1 矩陣物件 Matrix 3.2 矩陣的下標與索引 Matrix Index 3.3 向量與矩陣的合併: rbind() 與 cbind() 3.4 陣列物件 Array 3.5 列表物件 List 3.6 資料框架 Data Frame 3.7 資料框架函式 data.frame()", " Chapter 3 資料物件 {R} 是以物件導向為主的程式語言, 在 {R} 中, 資料或運算指令以具有名稱的 物件 (object), 形式儲存, 資料物件可以是 向量 (vector), 矩陣 (matrix), 陣列 (array), 列表 (Lists), 或 資料框架 (data frames) 等. 在 {R} 中, 資料分析基本上是產生資料物件, 對物件命名, 使用函式對物件運算操作. 透過指令, 很容易地對物件進行統計分析與統計繪圖. 上一章討論向量的基本操作, 本章進一步討論 {R} 的其他多維度資料物件, 包含 矩陣 (matrix), 陣列 (array), 列表 (Lists), 或資料框架 (data frames) 等. 3.1 矩陣物件 Matrix 矩陣 (matrix) 物件由包含相同的元素 (模式, mode) 組成的 \\(2\\)-維度 (2-dimension) 資料物件, 矩陣具有 維度 (dimension) 之屬性, 可以使用函式 dim() 檢視. 可以將矩陣視為一個向量具二維結構, 也可以將 矩陣 視為一個向量具 \\(2\\)-維度的陣列 (array). 3.1.1 矩陣函式 matrix() 使用者若要輸入一個簡單的矩陣資料, 列 \\(\\times\\) 欄 (列 \\(\\times\\) 行), 或希望以矩陣形式儲存資料, 可以用 函式 matrix(). matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) 其中引數為 nrow = r 正整數, 設定 列數 (row numbers). ncol = c 正整數, 設定 欄數 或 行數 (column number). byrow = FALSE: 在 {R} 中的自動設定, 矩陣資料是以欄 (行) 位 (column) 優先填滿. 要改變設定, 可改成 byrow = TRUE. dimnames = obj.list 輸入列表設定列位名與欄位名. 使用函式 dim() 可以回傳具有維度數屬性的資料物件之維度大小. ## numeric x.mat &lt;- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2) # one row first x.mat ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 dim(x.mat) ## [1] 2 3 y.mat &lt;- matrix(c(1, 2, 3, 4, 5, 6), ncol = 2) y.mat ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 z.mat &lt;- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, byrow = T) z.mat ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 p.mat &lt;- matrix(c(1, 2, 3, 4, 5, 6), ncol = 2, byrow = T) p.mat ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 w.mat &lt;- matrix(c(1:18), nrow = 3) w.mat ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 4 7 10 13 16 ## [2,] 2 5 8 11 14 17 ## [3,] 3 6 9 12 15 18 dim(y.mat) ## [1] 3 2 # character x.vec &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;) x.vec ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; y.mat &lt;- matrix(x.vec, nrow = 2, ncol = 3) # byrow = F y.mat ## [,1] [,2] [,3] ## [1,] &quot;a&quot; &quot;c&quot; &quot;e&quot; ## [2,] &quot;b&quot; &quot;d&quot; &quot;f&quot; y.mat &lt;- matrix(x.vec, nrow = 2, ncol = 3, byrow = T) y.mat ## [,1] [,2] [,3] ## [1,] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## [2,] &quot;d&quot; &quot;e&quot; &quot;f&quot; dim(y.mat) ## [1] 2 3 # dim m.vec.mat &lt;- 1:10 dim(m.vec.mat) &lt;- c(2, 5) m.vec.mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 dim(m.vec.mat) ## [1] 2 5 3.1.2 矩陣命名 dimnames() 矩陣的命名, 包含欄位名 (column name) 與列位名 (row name), 可以使用函式 dimnames() 分別給予矩陣命名. 可以用函式 dimnames() 同時檢視 matrix 之列位名與欄位名. 若要對讀取或命名矩陣的 列位名 (row name) 或 欄位名 (column name), 也可以用函式指令 rownames() 與 colnames(). # dimnames x.mat &lt;- matrix(1:6, nrow = 2, ncol = 3) dimnames(x.mat) &lt;- list(c(&quot;A1&quot;, &quot;A2&quot;), c(&quot;B1&quot;, &quot;B2&quot;, &quot;B3&quot;)) x.mat ## B1 B2 B3 ## A1 1 3 5 ## A2 2 4 6 dim(x.mat) ## [1] 2 3 dimnames(x.mat) ## [[1]] ## [1] &quot;A1&quot; &quot;A2&quot; ## ## [[2]] ## [1] &quot;B1&quot; &quot;B2&quot; &quot;B3&quot; rownames(x.mat) ## [1] &quot;A1&quot; &quot;A2&quot; colnames(x.mat) ## [1] &quot;B1&quot; &quot;B2&quot; &quot;B3&quot; # m.mat &lt;- matrix( c(1, 2, 3, 11, 12, 13), nrow = 2, ncol = 3, byrow = TRUE, dimnames = list(c(&quot;row1&quot;, &quot;row2&quot;), c(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;)) ) m.mat ## C1 C2 C3 ## row1 1 2 3 ## row2 11 12 13 dim(m.mat) ## [1] 2 3 dimnames(m.mat) ## [[1]] ## [1] &quot;row1&quot; &quot;row2&quot; ## ## [[2]] ## [1] &quot;C1&quot; &quot;C2&quot; &quot;C3&quot; rownames(m.mat) ## [1] &quot;row1&quot; &quot;row2&quot; colnames(m.mat) ## [1] &quot;C1&quot; &quot;C2&quot; &quot;C3&quot; 3.2 矩陣的下標與索引 Matrix Index 矩陣的 下標 或 索引 (index) 操作, 如同向量的下標與索引操作, 矩陣具有 \\(2\\)-維度下標向量, 個別下標向量可以輸入正整數, 負數, 整數向量, 欄位名等等. 例如, 可以使用 中括號 matrix.name[i, j] 可存取矩陣中的第 \\([i, j]\\) 元素; matrix.name[i, ] 可存取矩陣中的第 \\(i\\) 列 (\\(i\\)th row), matrix.name[ , j] 可存取矩陣中的第 \\(j\\) 欄 (\\(i\\)th column). 在 {R} 中顯示矩陣物件, [m, ] 出現在某特定元素左方時, 表示某特定元素在該矩陣物件之第 \\(m\\) 列 (row) 的位置; [ , n] 出現在某特定元素上方時, 表示某特定元素在該矩陣物件之第 \\(n\\) 欄 (column) 的位置. ## matrix index x.mat &lt;- matrix(c(1:12), 3, 4) x.mat ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 x.mat[2, 3] &lt;- 30 x.mat ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 30 11 ## [3,] 3 6 9 12 x.mat[2,] ## [1] 2 5 30 11 x.mat[, 3] ## [1] 7 30 9 x.mat[c(1, 3), c(2, 4)] ## [,1] [,2] ## [1,] 4 10 ## [2,] 6 12 # m.mat &lt;- matrix( c(1, 2, 3, 11, 12, 13), nrow = 2, ncol = 3, byrow = TRUE, dimnames = list(c(&quot;row1&quot;, &quot;row2&quot;), c(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;)) ) m.mat ## C1 C2 C3 ## row1 1 2 3 ## row2 11 12 13 m.mat[, c(&quot;C1&quot;, &quot;C2&quot;)] ## C1 C2 ## row1 1 2 ## row2 11 12 m.mat[c(&quot;row2&quot;),] ## C1 C2 C3 ## 11 12 13 m.mat[c(&quot;row1&quot;), c(&quot;C1&quot;, &quot;C3&quot;)] ## C1 C3 ## 1 3 矩陣下標與索引若僅選取 1 列 或 1 欄, 則會維度縮減產生向量, 若仍要產生矩陣, 則可加入參數 drop = FALSE. ## dimension reduction x.mat &lt;- matrix(1:8, nrow = 2, ncol = 4) x.mat[1,] # reduces to a vector ## [1] 1 3 5 7 x.mat[1, , drop = FALSE] # remains as a matrix ## [,1] [,2] [,3] [,4] ## [1,] 1 3 5 7 3.3 向量與矩陣的合併: rbind() 與 cbind() 在 {R} 中向量並不具有 沒有維度 (no dimension), 例如, 向量可以視為 \\(1 \\times k\\) 的 向量/矩陣, 也可以視為 \\(k \\times 1\\) 的 向量/矩陣, 但是, 當 向量 與 其它 向量/矩陣 進行運算時, 向量 會受到與其進行運算的矩陣物件影響, {R} 如何處理 向量 與 其它 向量/矩陣 進行運算並沒有清楚的規則, 有時視為 \\(1 \\times k\\) 若任由 {R} 的內在設定, 則將會有意想不到的運算結果, 因此在進行線性代數相關的計算, 若要避免混淆與錯誤, 初學者可將數學的 \\(1\\)-維度 \\(k\\)-個元素的向量, 重新定義成 {R} 的 \\(1 \\times k\\) 的矩陣 或是 \\(k \\times 1\\) 的矩陣, 然後再進行線性代數相關的計算. 同樣, 合併不同 列位數 (row number) 或 欄位數 (column number) 的向量或矩陣, 因為使用 recycle 原則必須小心. ## matrix cbind() and rbind() x.vec &lt;- c(1, 2, 3) y.vec &lt;- c(8, 9, 10) rbind(x.vec, y.vec) # vector as row vector ## [,1] [,2] [,3] ## x.vec 1 2 3 ## y.vec 8 9 10 cbind(x.vec, y.vec) # vector as col vector ## x.vec y.vec ## [1,] 1 8 ## [2,] 2 9 ## [3,] 3 10 # x.mat &lt;- matrix(c(11:16), 2, 3) rbind(x.mat, x.vec) # vector as row vector ## [,1] [,2] [,3] ## 11 13 15 ## 12 14 16 ## x.vec 1 2 3 cbind(x.mat, y.vec) # warning ## Warning in cbind(x.mat, y.vec): number of rows of result is not a multiple ## of vector length (arg 2) ## y.vec ## [1,] 11 13 15 8 ## [2,] 12 14 16 9 # x.vec &lt;- c(1, 2) y.vec &lt;- c(8, 9) rbind(x.vec, y.vec) # vector as row vector ## [,1] [,2] ## x.vec 1 2 ## y.vec 8 9 cbind(x.vec, y.vec) # vector as col vector ## x.vec y.vec ## [1,] 1 8 ## [2,] 2 9 # x.mat &lt;- matrix(c(11:14), 2, 2) z.mat &lt;- rbind(x.mat, x.vec) # vector as row vector z.mat ## [,1] [,2] ## 11 13 ## 12 14 ## x.vec 1 2 cbind(x.mat, y.vec) # vector as col vector ## y.vec ## [1,] 11 13 8 ## [2,] 12 14 9 rbind(z.mat, y.vec) # vector as row vector ## [,1] [,2] ## 11 13 ## 12 14 ## x.vec 1 2 ## y.vec 8 9 cbind(z.mat, y.vec) # warning ## Warning in cbind(z.mat, y.vec): number of rows of result is not a multiple ## of vector length (arg 2) ## y.vec ## 11 13 8 ## 12 14 9 ## x.vec 1 2 8 3.4 陣列物件 Array 陣列 (array) 物件也由包含相同模式 (mode) 的元素組成的 \\(p\\)-維資料物件, 也可以將陣列視為一個向量具 \\(p\\)-維結構. 使用函式 array() 產生陣列. {R} 顯示 \\(3\\)-維陣列物件 \\(m \\times n \\times k\\), [m, , ] 出現在某特定元素之前時, 表示某特定元素在該陣列物件之第 \\(m\\) 列 (row) 的位置; [ , n, ] 出現在某特定元素之前時, 表示某特定元素在該陣列物件之第 \\(n\\) 欄 (column) 的位置, 依此類推. [ , , k] 表示 \\(3\\)-維陣列的第 1, 2-維度之矩陣. 陣列的命名, 與矩陣類似, 可以使用函式 dimnames() 分別給予陣列命名. 可以用函式 dimnames() 同時檢視 array 之列位名與欄位名. 陣列的 下標 或 索引 (index) 之操作, 與矩陣下標或索引的操作類似, 使用 中括號 ([i, j, k]). 若要對讀取或命名陣列的第 1 維度 (列位名, row name) {或 第 2 維度 (欄位名, column name**), 也可以用函式指令 rownames() 與 colnames(). ## array() a.vec &lt;- 1:24 a.vec ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 b.array &lt;- array(a.vec, dim = c(4, 3, 2), dimnames = list(c(&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;, &quot;x4&quot;), c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;), c(&quot;z1&quot;, &quot;z2&quot;))) b.array ## , , z1 ## ## y1 y2 y3 ## x1 1 5 9 ## x2 2 6 10 ## x3 3 7 11 ## x4 4 8 12 ## ## , , z2 ## ## y1 y2 y3 ## x1 13 17 21 ## x2 14 18 22 ## x3 15 19 23 ## x4 16 20 24 mode(b.array) ## [1] &quot;numeric&quot; dim(b.array) ## [1] 4 3 2 length(b.array) ## [1] 24 dimnames(b.array) ## [[1]] ## [1] &quot;x1&quot; &quot;x2&quot; &quot;x3&quot; &quot;x4&quot; ## ## [[2]] ## [1] &quot;y1&quot; &quot;y2&quot; &quot;y3&quot; ## ## [[3]] ## [1] &quot;z1&quot; &quot;z2&quot; rownames(b.array) ## [1] &quot;x1&quot; &quot;x2&quot; &quot;x3&quot; &quot;x4&quot; colnames(b.array) ## [1] &quot;y1&quot; &quot;y2&quot; &quot;y3&quot; # array index a.vec ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 b.array &lt;- array(a.vec, dim = c(4, 3, 2), dimnames = list(c(&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;, &quot;x4&quot;), c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;), c(&quot;z1&quot;, &quot;z2&quot;))) b.array ## , , z1 ## ## y1 y2 y3 ## x1 1 5 9 ## x2 2 6 10 ## x3 3 7 11 ## x4 4 8 12 ## ## , , z2 ## ## y1 y2 y3 ## x1 13 17 21 ## x2 14 18 22 ## x3 15 19 23 ## x4 16 20 24 b.array[3, 2, 1] ## [1] 7 b.array[4, 3, 2] ## [1] 24 b.array[2, c(1, 3), 1] ## y1 y3 ## 2 10 b.array[3, c(2, 3), 1] ## y2 y3 ## 7 11 b.array[2, ,] ## z1 z2 ## y1 2 14 ## y2 6 18 ## y3 10 22 b.array[, 2,] ## z1 z2 ## x1 5 17 ## x2 6 18 ## x3 7 19 ## x4 8 20 b.array[, , 2] ## y1 y2 y3 ## x1 13 17 21 ## x2 14 18 22 ## x3 15 19 23 ## x4 16 20 24 3.5 列表物件 List 列表 (list) 是一個特殊的 向量, 這特殊的向量中的元素是物件. 列表物件 元素的模式 (mode) 是 複雜模式 (complex mode) 列表物件是由資料物件有順序組成, 列表物中的 ``元素’’, 稱作 成份 (component), 是物件本身, 列表物中的成份是有順序的 (order sequence), 成份物件的元素模式, 沒有任合限制, 每一個別成份的物件之原型模式可以不相同. 列表的產生通常先決定每一個成分的物件, 然後再組合成列表. 3.5.1 列表函式 list() 使用函式 list() 將個別成分組成列表. {R} 許多統計分析的結果常常包含 不同物件, 例如, 迴歸模型分析包含 參數估計, 變異數分析, 預測值與殘差, 每一成分的長度與模式不一, 模型分析產生的結果最後多以列表儲存. ## list() ## list w/o component names x.vec &lt;- 1:4 y.vec &lt;- c(&quot;Male&quot;, &quot;Female&quot;) z.mat &lt;- matrix(1:9, nrow = 3, ncol = 3) xyz.list &lt;- list(x.vec, y.vec, z.mat) xyz.list ## [[1]] ## [1] 1 2 3 4 ## ## [[2]] ## [1] &quot;Male&quot; &quot;Female&quot; ## ## [[3]] ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 mode(xyz.list) ## [1] &quot;list&quot; length(xyz.list) ## [1] 3 dim(xyz.list) ## NULL names(xyz.list) ## NULL class(xyz.list) ## [1] &quot;list&quot; ## list w/ component names x.num &lt;- c(1, 3, 6) y.str &lt;- c(&quot;chocolate&quot;, &quot;vanilla&quot;, &quot;strawberry&quot;) xy.list &lt;- list(x.num.var = x.num, y.str.var = y.str) xy.list ## $x.num.var ## [1] 1 3 6 ## ## $y.str.var ## [1] &quot;chocolate&quot; &quot;vanilla&quot; &quot;strawberry&quot; # list = data matrix id.vec &lt;- c(1, 2, 3, 4) age.vec &lt;- c(35, 55, 45, 25) sex.vec &lt;- c(&quot;Male&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Female&quot;) disease.vec &lt;- c(&quot;Yes&quot;, &quot;No&quot;, &quot;No&quot;, &quot;Yes&quot;) x.list &lt;- list( id = id.vec, age = age.vec, sex = sex.vec, disease = disease.vec ) x.list ## $id ## [1] 1 2 3 4 ## ## $age ## [1] 35 55 45 25 ## ## $sex ## [1] &quot;Male&quot; &quot;Male&quot; &quot;Female&quot; &quot;Female&quot; ## ## $disease ## [1] &quot;Yes&quot; &quot;No&quot; &quot;No&quot; &quot;Yes&quot; 3.5.2 列表的下標與索引 List Index 列表物件的 下標 或 索引 之操作, 與矩陣 或 陣列之操作有所不同, 若一個名字為 List.Name 的列表物件, 要取得 list 其中的 第 i.number 成份, 須使用 List.Name[[i]]. 注意, 在列表物件的下標操作, [[i.number]] 與 [i.number] 是不一樣的. ## list index ## list w/o component names x.vec &lt;- 1:4 y.vec &lt;- c(&quot;Male&quot;, &quot;Female&quot;) z.mat &lt;- matrix(1:9, nrow = 3, ncol = 3) xyz.list &lt;- list(x.vec, y.vec, z.mat) xyz.list ## [[1]] ## [1] 1 2 3 4 ## ## [[2]] ## [1] &quot;Male&quot; &quot;Female&quot; ## ## [[3]] ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 xyz.list[1] ## [[1]] ## [1] 1 2 3 4 xyz.list[[1]] ## [1] 1 2 3 4 xyz.list[2] ## [[1]] ## [1] &quot;Male&quot; &quot;Female&quot; xyz.list[[3]] ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 xyz.list[3] ## [[1]] ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 若列表中的 成份 (component) 有另外命名為 comp.name, 可以使用函式 List.Name\\$comp.name 取得成份名字, 會與使用函式 List.Name[[comp.name]] 取得相同結果. 在 List.Name$comp.name 或 List.Name[[comp.name]] 加上 中括號 等, 可以取得 List.Name$comp.name 中的元素. [[i.number]] 可以適用在計算指標, 但 $ 僅能使用在有設定的成分名的列表. 若列表的單一成份內有多維度物件 可使用巢狀下標取出資料. # list w/ component names x.vec &lt;- 1:4 y.vec &lt;- c(&quot;Male&quot;, &quot;Female&quot;) z.mat &lt;- matrix(1:9, nrow = 3, ncol = 3) xyz.list &lt;- list(class = x.vec, gender = y.vec, score = z.mat) xyz.list ## $class ## [1] 1 2 3 4 ## ## $gender ## [1] &quot;Male&quot; &quot;Female&quot; ## ## $score ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 xyz.list$class ## [1] 1 2 3 4 xyz.list[[&quot;class&quot;]] ## [1] 1 2 3 4 xyz.list[[&quot;class&quot;]][2] ## [1] 2 # xyz.list$gender ## [1] &quot;Male&quot; &quot;Female&quot; xyz.list[[&quot;gender&quot;]][1] ## [1] &quot;Male&quot; # xyz.list$score ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 xyz.list[[&quot;score&quot;]][2, 3] ## [1] 8 3.6 資料框架 Data Frame 一組資料通常包含數字與文字, 在 {R} 中的向量與矩陣物件, 只允許相同的變數型式, 若要同時存入數字變數與文字變數, {R} 可以使用 列表 (list) 與 函式指令 list(), 列表資料內可包含不同屬性的變數值. 資料框架 (data frame) 是列表物件的一種特殊情境. 在資料框架內的每個變數之觀測值數目 (向量長度) 都相等, 類似矩陣型式, 但是每個變數的變數值不一定是相同的模式, 因此資料框架對統計人員而言, 常稱為 資料矩陣 (data matrix), 是一般統計資料分析常用的形式. 注意: {R} 資料框架物件操作類似 {R} 矩陣物件, 但 {R} 資料框架物件本質上為 {R} 列表物件. 3.7 資料框架函式 data.frame() {R} 可以使用函式 data.frame() 將資料儲存成資料框架物件. 輸入時須注意每個變數之觀測值數目 (向量長度) 都必須相等, 若有缺失值, 須先將缺失值符號輸入在向量內. ## data frame id.vec &lt;- c(1, 2, 3, 4) age.vec &lt;- c(35, 55, 45, 25) sex.vec &lt;- c(&quot;Male&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Female&quot;) disease.vec &lt;- c(&quot;Yes&quot;, &quot;No&quot;, &quot;No&quot;, &quot;Yes&quot;) x.df &lt;- data.frame( id = id.vec, age = age.vec, sex = sex.vec, disease = disease.vec ) mode(x.df) ## [1] &quot;list&quot; class(x.df) ## [1] &quot;data.frame&quot; x.df ## id age sex disease ## 1 1 35 Male Yes ## 2 2 55 Male No ## 3 3 45 Female No ## 4 4 25 Female Yes x.df$age ## [1] 35 55 45 25 x.df$disease ## [1] &quot;Yes&quot; &quot;No&quot; &quot;No&quot; &quot;Yes&quot; 3.7.1 資料框架的下標與索引 Data Frame Index 資料框架的 下標 或 索引 (index) 操作, 如同矩陣的下標與索引操作, 可以輸入正整數, 負數, 整數向量, 欄位名等等. 矩陣具有 2-維度下標向量, 例如, 可以使用 中括號 dataframe.name[i, j] 可存取資料框中的第 \\([i, j]\\) 元素; dataframe.name[i, ] 可存取資料框中的第 \\(i\\) 列 (\\(i\\)th row), dataframe.name[ , j] 可存取資料框中的第 \\(j\\) 欄 (\\(i\\)th column). 資料框架是列表的特例, 因此資料框架的 下標 或 索引 (index) 操作, 也可如同列表的下標與索引操作. 若一個名為 data.Name 的資料框架, 要取的其中的 第 `i.number'' 變數 (成份), 須使用data.Name[[i]]. 注意, 在資料框架物件的下標操作,[[i.number]]與[i.number]是不一樣的. 若資料框架中的變數命名為variable.name, 可以使用函式dataframe.Name\\(variable.name` 取得變數資料, 會與使用函式 `dataframe.Name[[variable.name]] 取得相同結果. 在 `dataframe.Name\\)variable.name或dataframe.Name[[variable.name]]加上 **中括號**[k]等, 可以取得dataframe.Name$variable.name中的元素.[[i.number]]` 可以適用在計算指標, 但 $ 僅能使用在有設定變數名的資料框架. ## data frame index data(Puromycin) Puromycin ## conc rate state ## 1 0.02 76 treated ## 2 0.02 47 treated ## 3 0.06 97 treated ## 4 0.06 107 treated ## 5 0.11 123 treated ## 6 0.11 139 treated ## 7 0.22 159 treated ## 8 0.22 152 treated ## 9 0.56 191 treated ## 10 0.56 201 treated ## 11 1.10 207 treated ## 12 1.10 200 treated ## 13 0.02 67 untreated ## 14 0.02 51 untreated ## 15 0.06 84 untreated ## 16 0.06 86 untreated ## 17 0.11 98 untreated ## 18 0.11 115 untreated ## 19 0.22 131 untreated ## 20 0.22 124 untreated ## 21 0.56 144 untreated ## 22 0.56 158 untreated ## 23 1.10 160 untreated Puromycin$rate ## [1] 76 47 97 107 123 139 159 152 191 201 207 200 67 51 84 86 98 115 ## [19] 131 124 144 158 160 Puromycin$state ## [1] treated treated treated treated treated treated treated ## [8] treated treated treated treated treated untreated untreated ## [15] untreated untreated untreated untreated untreated untreated untreated ## [22] untreated untreated ## Levels: treated untreated Puromycin[1] ## conc ## 1 0.02 ## 2 0.02 ## 3 0.06 ## 4 0.06 ## 5 0.11 ## 6 0.11 ## 7 0.22 ## 8 0.22 ## 9 0.56 ## 10 0.56 ## 11 1.10 ## 12 1.10 ## 13 0.02 ## 14 0.02 ## 15 0.06 ## 16 0.06 ## 17 0.11 ## 18 0.11 ## 19 0.22 ## 20 0.22 ## 21 0.56 ## 22 0.56 ## 23 1.10 Puromycin[1][[1]] ## [1] 0.02 0.02 0.06 0.06 0.11 0.11 0.22 0.22 0.56 0.56 1.10 1.10 0.02 0.02 ## [15] 0.06 0.06 0.11 0.11 0.22 0.22 0.56 0.56 1.10 Puromycin$state[1:3] ## [1] treated treated treated ## Levels: treated untreated Puromycin[1:3, 1:2] ## conc rate ## 1 0.02 76 ## 2 0.02 47 ## 3 0.06 97 "],
["datainout.html", "Chapter 4 資料輸入與輸出 4.1 資料框架 4.2 輸入外部 ASCII 資料檔案至 R 資料框架: 空白分隔 4.3 輸入外部 ASCII 資料檔案至 R 資料框架: 逗號分隔 4.4 R 內建資料框架 4.5 輸出 {R} 資料 4.6 儲存 {R} 格式資料檔", " Chapter 4 資料輸入與輸出 在 {R} 中, 資料以具有名稱的 物件 形式儲存, 它們可以是向量 (vector), 矩陣 (matrix), 陣列 (array), 列表 (Lists), 或 資料框架 (data frames) 等. 簡單的資料, 可以直接在 {R} 視窗中輸入, 大型資料, 通常先以資料庫軟體, 試算表軟體等輸入儲存成外部檔案, 由 {R} 從外部檔案中讀入, 而不是直接在 {R} 中使用鍵盤輸入. {R} 可以讀入純文字 ASCII 格式的資料檔, {R} 也有許多套件可以讀入許多不同格式檔案與資料庫關聯檔案, SAS, SPSS, STATA, EXCEL, 網路公開資料, web open data (XML, HTML JSON), image, texts, stock market, social media 等. 每一資料的儲存格式不盡相同, 通常由儲存資料的軟體所決定, 通常可由檔案的附檔名得知資料的儲存格式. {R} 對輸入資料的原先設計, 假設使用者利用其他工具, 如文書檔編輯器, 資料庫軟體, 或試算表軟體等, 輸入原始資料並儲存成 {R} 的外部原始資料檔案, 任何外部原始資料檔案, 必須修改成特定的 {R} 輸入檔格式, 以使它們符合 {R} 輸入外部原始資料檔案的要求, 對統計分析來說, 這是比較容易地進行外部原始資料的管理. 如同多數專業統計軟體, 不是專業的資料庫軟體, 外部原始資料的管理, 通常都是藉由專業的資料庫軟體進行. 任何資料庫軟體都可以將資料輸出純文字 ASCII 格式的資料檔案, 且任何資料庫軟體或文書檔編輯器都可讀入純文字 ASCII 格式的資料檔案. 4.1 資料框架 統計計算可以進行分析的資料, 通常有一個的簡單的基本架構, 在 {R} 稱作 資料框架 (data frame). 資料框架是類似於在 SAS, STATA 等的 dataset 架構. 資料框架通常類似矩陣, 資料框架也類似矩形的 交叉列聯表 (cross table). 在 {R} 中, 資料框架是統計分析中最基本的資料結構, 許多統計模型分析都必須用到資料框架結構, 資料框架與矩陣類似, 不同的地方在資料框架變數不需要是相同的變數形式或種類, 實數變數, 整數變數, 文字類別變數, 邏輯變數等都可放在同一資料框架中, 資料框架的基本架構如下表. 但是矩陣物件只能有相同的變數 模式 (mode) 的元素組成. 原始資料檔案 DMTKRtabsep.txt 與 DMTKRblanksep.txt: 以純文字空白分隔儲存 No age sex DM DMyr preAC prePC postAC postPC Med SIDE PREKS POSKS ABS INFECT 1 67 0 0 10 120 160 140 180 0 0 56 92 1 0 2 67 0 0 11 100 150 150 220 0 1 62 62 0 1 3 72 1 0 4 150 200 120 150 2 0 60 94 1 0 4 82 1 0 8 150 200 160 250 0 1 47 90 1 0 5 73 1 0 3 85 110 140 200 0 0 44 88 0 0 資料框架有一些特徵, 舉例如下. 第 1 列 (橫列, row), 可以是變數的 變數名 (variable names) 第 1 列 (row), 有時是變數的 欄位標籤 (column label), 而第 2 列 (row) 為變數名. 每個變數各自形成 1 欄 (縱行, column). 第 1 欄 (縱行, column) 為個體辨識碼 (label, identification), 或稱 列位標籤 (row label). 每一欄 (變數) 的變數值形式可以是實數, 文字, 邏輯變數. 第一欄 (column) 有時候是 列位標籤 (row label). 變數名稱以英文為起始, 之後可包含文字與數字, 不可使用標點符號與空格, 有些軟體可以使用 underscore _. 變數值通常為數字, 整數或文字, 儘量避免直接輸入文字, 因為大小寫, 符號, 空格的輸入經常造成錯誤. 若原始資料沒有 變數名 或 標籤, {R} 讀入資料時可以同時輸入變數名, 或讀入資料後, 再輸入變數名. 4.2 輸入外部 ASCII 資料檔案至 R 資料框架: 空白分隔 任何資料庫軟體都可以將資料輸出純文字 ASCII 格式的資料檔案, 且任何資料庫軟體或文書檔編輯器都可讀入純文字 ASCII 格式的資料檔案. 統計分析通常需要讀取外部 原始資料 (raw data) 檔案, {R} 對輸入資料的原先設計時讀入純文字 ASCII 格式的資料檔案, 暫存到電腦的記憶體上, 形成 {R} 資料框架, 對初學者而言讀入或輸出外部純文字 ASCII 格式的資料檔案最為容易. {R} 統計分析主要在資料框架 (data frame) 中的變數進行分析操作, {R} 使用資料框架函式指令 read.table() 或 read.csv() 讀入外部資料檔案, 對初學者而言最為容易. 而其他函式, 例如, scan() 讀取外部資料, 對初學者而言較困難. 為了可以直接讀取整個外部檔案進入 {R} 並形成 {R} 的資料框架物件, 純文字 ASCII 格式的外部檔案常常要求有特定的格式, 例如: 多數檔編輯器, 資料庫, 試算表等軟體可以存取. 第一的列 (the first row) 可以有該資料各個變數的 變數名 (variable names) 或是 行位名, 欄位名 (column name) 或是 欄位標籤 (column label). 第一欄 (the first column) 有時候是 列的標籤 (row label) 或是 列的名字 (row name). 其餘的列 (row), 是個別變數的觀測數值. 變數值之間常以 空白鍵 () (blank space) 分開, 也可以其他特定符號 Tab 分隔. 若是變數資料是文字列型, 通常以雙引號包含, 但有時例外, 需視資料原始儲存軟體的設定. 純文字 ASCII 格式, 變數值以空格分開的副檔名通常為 .dat, .prn 或 .txt. 若變數之間以 , (逗號) 分開變數值的 ASCII 形式檔案, 一般稱為 comma-separated-variable format 或 CSV format, 檔案名通常以 .csv 作為延伸檔名. 初學者的原始資料之變數名稱 (variable name) 不要使用 中文, 空格, 盡量少用 . (點, dot), 或 _ (underscore). 中文, 以免容易造成錯誤. 初學者盡量不要使用 文字 作為變數值 (observed value). 變數值之間以空白鍵或 特定符號 Tab 鍵分開意義不同, 不同軟體讀入這 2 種 ASCII 資料有所不同. 這很難區分, 初學者盡量使用 CSV format. # DMTKRblanksep.txt = &quot; &quot; single space separate Rblanksep.df = read.table(&quot;C:/RData/DMTKRblanksep.txt&quot;, header = TRUE, row.names = NULL, dec = &quot;.&quot;) head(Rblanksep.df) ## No age sex DM DMyr preAC prePC postAC postPC Med SIDE PREKS POSKS ABS ## 1 1 67 0 0 10 120 160 140 180 0 0 56 92 1 ## 2 2 67 0 0 11 100 150 150 220 0 1 62 62 0 ## 3 3 72 1 0 4 150 200 120 150 2 0 60 94 1 ## 4 4 82 1 0 8 150 200 160 250 0 1 47 90 1 ## 5 5 73 1 0 3 85 110 140 200 0 0 44 88 0 ## 6 6 76 0 0 1 120 150 120 200 0 1 52 94 1 ## INFECT ## 1 0 ## 2 1 ## 3 0 ## 4 0 ## 5 0 ## 6 0 str(Rblanksep.df) ## &#39;data.frame&#39;: 78 obs. of 15 variables: ## $ No : int 1 2 3 4 5 6 7 8 9 10 ... ## $ age : int 67 67 72 82 73 76 76 77 64 64 ... ## $ sex : int 0 0 1 1 1 0 0 0 0 0 ... ## $ DM : int 0 0 0 0 0 0 0 1 0 0 ... ## $ DMyr : int 10 11 4 8 3 1 1 35 5 5 ... ## $ preAC : int 120 100 150 150 85 120 120 200 130 130 ... ## $ prePC : int 160 150 200 200 110 150 150 250 180 180 ... ## $ postAC: int 140 150 120 160 140 120 120 230 100 100 ... ## $ postPC: int 180 220 150 250 200 200 200 300 150 150 ... ## $ Med : int 0 0 2 0 0 0 0 1 0 0 ... ## $ SIDE : int 0 1 0 1 0 1 0 1 0 1 ... ## $ PREKS : int 56 62 60 47 44 52 48 42 40 45 ... ## $ POSKS : int 92 62 94 90 88 94 96 90 94 96 ... ## $ ABS : int 1 0 1 1 0 1 0 1 1 0 ... ## $ INFECT: int 0 1 0 0 0 0 0 0 0 0 ... ## complete read.table ## DMTKRblanksep.txt = &quot; &quot; single space separate Rblanksep.df = read.table(&quot;C:/RData/DMTKRblanksep.txt&quot;, header = TRUE, sep = &quot; &quot;, quote = &quot;\\&quot;&#39;&quot;, dec = &quot;.&quot;, row.names = NULL, # col.names, as.is = TRUE, # as.is = !stringsAsFactors, na.strings = c(&quot;&quot;, &quot;.&quot;, &quot;NA&quot;)) head(Rblanksep.df) str(Rblanksep.df) 4.3 輸入外部 ASCII 資料檔案至 R 資料框架: 逗號分隔 另一種原始資料以純文字 ASCII 格式檔儲存, 且變數值之間是以 逗號 , (comma) 分隔的 ASCII 檔案, 其格式化稱為 csv format (comma-separated-variable format), 副檔名通常為 .csv. 使用函式 read.table() 自動內設以空格分開變數值, 必須更改分開變數值符號為 ,. 使用函式 read.csv() 自動內設以 , 分開變數值. ## read data file: DMTKRcsv.csv read_table.df &lt;- read.table(&quot;C:/RData/DMTKRcsv.csv&quot;, header = TRUE, row.names = NULL, sep = &quot;,&quot;, dec = &quot;.&quot;) head(read_table.df, n = 3) ## No age sex DM DMyr preAC prePC postAC postPC Med SIDE PREKS POSKS ABS ## 1 1 67 0 0 10 120 160 140 180 0 0 56 92 1 ## 2 2 67 0 0 11 100 150 150 220 0 1 62 62 0 ## 3 3 72 1 0 4 150 200 120 150 2 0 60 94 1 ## INFECT ## 1 0 ## 2 1 ## 3 0 # simple one read_csv.df &lt;- read.csv(&quot;C:/RData/DMTKRcsv.csv&quot;) head(read_csv.df, n = 3) ## No age sex DM DMyr preAC prePC postAC postPC Med SIDE PREKS POSKS ABS ## 1 1 67 0 0 10 120 160 140 180 0 0 56 92 1 ## 2 2 67 0 0 11 100 150 150 220 0 1 62 62 0 ## 3 3 72 1 0 4 150 200 120 150 2 0 60 94 1 ## INFECT ## 1 0 ## 2 1 ## 3 0 # read_csv.df &lt;- read.csv(&quot;C:/RData/DMTKRcsv.csv&quot;, header = TRUE, row.names = NULL, sep = &quot;,&quot;, dec = &quot;.&quot;) head(read_csv.df, n = 3) ## No age sex DM DMyr preAC prePC postAC postPC Med SIDE PREKS POSKS ABS ## 1 1 67 0 0 10 120 160 140 180 0 0 56 92 1 ## 2 2 67 0 0 11 100 150 150 220 0 1 62 62 0 ## 3 3 72 1 0 4 150 200 120 150 2 0 60 94 1 ## INFECT ## 1 0 ## 2 1 ## 3 0 4.4 R 內建資料框架 {R} 有許多內建資料框架, 另外貢獻套件 (contributed packages) 也有許多內建的資料框架, 可以使用 data() 查看 {R} 內建資料框架名稱, 或使用 library(help = \"datasets\") 查看 {R} 內建資料框架名稱. 使用 data(package = \"package.name\") 查看名稱為 package.name 套件中的資料框架名稱, 載入資料框架, 可用 data(data.name) 載入 {R} 內建名稱為 data.name 資料框架使用, 或 data(package.data.name, package = \"package.name\") 載入名稱為 package.name 套件中, 名稱為 pack.data.name 資料框架使用. # data() # check names of datasets data(Orange) # use {R} build-in dataset = Orange # help(Orange) head(Orange) ## Grouped Data: circumference ~ age | Tree ## Tree age circumference ## 1 1 118 30 ## 2 1 484 58 ## 3 1 664 87 ## 4 1 1004 115 ## 5 1 1231 120 ## 6 1 1372 142 # library(MASS) # help(package = MASS) # data(package = &quot;MASS&quot;) # check MASS package data set data(VA, package = &quot;MASS&quot;) # use MASS package dataset = VA # help(VA) head(VA) ## stime status treat age Karn diag.time cell prior ## 1 72 1 1 69 60 7 1 0 ## 2 411 1 1 64 70 5 1 10 ## 3 228 1 1 38 60 3 1 0 ## 4 126 1 1 63 60 9 1 10 ## 5 118 1 1 65 70 11 1 10 ## 6 10 1 1 49 20 5 1 0 4.5 輸出 {R} 資料 由 {R} 程式產生的資料, 可以儲存成外部資料檔案. 包含函式 write.table() 與 write.csv(). 其引數如下. x = 匯出的 {R} 物件名 file = 路徑與檔案名稱 append = FALSE 預設不在檔案末端附加資料 quote = \"\\\"\" 預設文字變數值使用雙引號將 sep = \" \" 預設空白分隔符號 eol = \"\\n\" 設定換行符號 na = NA 設定 NA 符號 dec = '.' 設定小數點符號 row.names = TRUE 設定輸出 row names col.names = TRUE 設定輸出變數名 (column names) qmethod = c(\"escape\", \"double\") 文字變數值有當引號時的分隔符號 fileEncoding = \"\" 設定檔案編碼 使用函式 write.csv() 儲存檔案與函式 write.table() 類似, 但使用 sep = \",\". 4.6 儲存 {R} 格式資料檔 函式 saveRDS() 可將資料儲存成 {R} 格式的外部資料檔案. 函式 readRDS() 可將外部 {R} 格式資料輸入. 主要是在用在大數據檔案, 若每次輸入外部資料檔案非常費時, 可以將已經轉成 data frame 物件的資料直接儲存成 {R} 格式的外部資料檔案. 只要使用函式 readRDS() 輸入, 可以節省許多時間. {R} 另外一組函式 save() 與函式 load() 有類似功能, 較較不方便. ## saveRDS() and save() x &lt;- c(1:5) saveRDS(x, file = &quot;C:/RData/x.Rds&quot;) save(x, file = &quot;C:/RData/x.Rda&quot;) # working directory ## readRDS() new_x &lt;- readRDS(file = &quot;C:/RData/x.Rds&quot;) new_x ## [1] 1 2 3 4 5 ## load() -- note the result new_x &lt;- load(file = &quot;C:/RData/x.Rda&quot;) new_x ## [1] &quot;x&quot; x ## [1] 1 2 3 4 5 "],
["dataviz.html", "Chapter 5 資料視覺化分析 5.1 視覺化分析原則 5.2 繪圖套件 ggplot2 5.3 類別變數 5.4 連續變數 5.5 混合變數 5.6 分組繪圖", " Chapter 5 資料視覺化分析 繪圖文法是讓一個圖形容易思考, 合理討論與溝通的抽像規則. Leland Wilkinson (1999), The Grammar of Graphics. {R} 內建許多繪圖工具函式, 這些繪圖工具可以顯示各種統計繪圖並且自建一些全新的圖. {R} 繪圖工具函式之特色是用同一個繪圖函式, 對不同類型的物件, 可以作出不同的圖形. 繪圖工具函式既可互動式使用, 也可以批次處理使用. 在許多情況下, 使用互動式 (interactive) 執行 {R} 的圖形繪製, 是一個相當有效的方式. {R} 基本繪圖工具包含 高階繪圖函式 與 低階繪圖函式, 或是合併二種方式形成互動式繪圖函式: 高階繪圖函式 (high-levlel plotting functions): 直接形成完整圖形, 圖形包括坐標軸, 標籤, 標題等等. 低階繪圖函式 (low-level plotting functions): 是將 點, 線, 座標與標籤等逐步形成圖形. 繪圖工具函式所產生之圖形結果, 無法指定成物件, 必須送到 圖形裝置 (graphic device), 圖形裝置可以是一個視窗或某一特定格式之圖形檔案, {R} 可以將圖形儲存在各種圖形裝置, 包含 pdf, ps, jpg, png 檔案等等. 在 {R} 中還有有一個獨立的強大之繪圖系統, grid 套件, 類似 Splus 裏的 Trellis 繪圖系統. 根據 grid 套件, 所建構的另一個較容易使用之 lattice, ggplot2 等. 可以產生多重漂亮起專業的統計繪圖. 目前主流使用 tidyverse 套件系統 包含許多不同套件, 提供資料科學一些實用的函式, 其中 ggplot2 為視覺化分析套件. 以套件 ggplot2 為基礎, 已經衍生出許多其他繪圖套件. 5.1 視覺化分析原則 Edward Tufte (2006) 在 Beautiful Evidence 書中提出一些視覺化分析原則. 顯示比較. 顯示因果關係或關聯性. 顯示多變量資料. 整合不同資料的證據. 描述與紀錄證據. 顯示實質內容最重要. 5.2 繪圖套件 ggplot2 繪圖套件 ggplot2 是一個龐大的繪圖系統, 開始學習 ggplot2 的程式語言會有些困難, 但中等程度複雜的圖形, 使用 ggplot2 通常會比使用 R base 繪圖系統容易. 統計繪圖學習方式可從已經發表且有程式碼的圖形學起, 例如, https://www.r-graph-gallery.com/index.html. ggplot2 的概念是使用結構性的語法, 先指定資料, 然後指定變數, 再指定幾何元素, 最後處裡標題與標注數據以及背景的主題式樣. 必要時考慮分組呈現相同圖形. ggplot2 的概念如同繪畫, 可隨時 使用 + 加上圖層 (layers), 更新或取代原有圖層. data: 選取資料. mapping (aes): 選取資料內變數進行對應或映射 x-變數, y-變數, treat, fill, shape, size, etc. geoms: 幾何物件 geometric object point, line, bar, shapes, ribbon, polygon, smooth, text etc. stat: 計算統計量/變數轉換, statistics position: 調整位置 position adjustments. Table: ggplot2 指令與引數 函式 ggplot() 基本程式如下. ggplot(data = data_name, aes(x = variable_name, y = variable_name, ... &lt;other variable_name mappings&gt;)) + geom_&lt;type&gt;() + ... Prentice (1973) 報告一個研究, 關於年長退伍軍人罹患肺癌, 且無法接受手術之臨床試驗, 病患在榮民醫院隨機接受標準治療方法或新的化學治療方法, 比較治療的主要結果變數為死亡時間, 變數名稱列在表. 資料在檔案 survVATrial.csv. 變數 描述 treat (therapy) 治療組別: 0 = 標準; 1 = 新治療 cellcode 細胞型態; 1 = 鱗狀細胞; 2 = 小細胞; 3 = 腺體細胞; 4 = 大細胞 time 存活時間, 診斷日期至死亡日期, 單位以日計 censor 設限狀態: 0 = 設限; 1 = 死亡 kps Karnofsky performance score, 診斷時身體狀態表現的分數 diagtime 診斷到隨機分配的時間, 以月計 age 診斷時的年齡 (以年計) prior 先前是否接受治療; 0 = 無; 1 = 有 dd &lt;- read.table(&quot;./Data/survVATrial.csv&quot;, header = TRUE, sep = &quot;,&quot;, quote = &quot;\\&quot;&#39;&quot;, dec = &quot;.&quot;, row.names = NULL, # col.names, as.is = TRUE, # as.is = !stringsAsFactors, na.strings = c(&quot;.&quot;, &quot;NA&quot;)) head(dd) ## treat cellcode time censor diagtime kps age prior ## 1 0 1 72 1 60 7 69 0 ## 2 0 1 411 1 70 5 64 10 ## 3 0 1 228 1 60 3 38 0 ## 4 0 1 126 1 60 9 63 10 ## 5 0 1 118 1 70 11 65 10 ## 6 0 1 10 1 20 5 49 0 str(dd) ## &#39;data.frame&#39;: 137 obs. of 8 variables: ## $ treat : int 0 0 0 0 0 0 0 0 0 0 ... ## $ cellcode: int 1 1 1 1 1 1 1 1 1 1 ... ## $ time : int 72 411 228 126 118 10 82 110 314 100 ... ## $ censor : int 1 1 1 1 1 1 1 1 1 0 ... ## $ diagtime: int 60 70 60 60 70 20 40 80 50 70 ... ## $ kps : int 7 5 3 9 11 5 10 29 18 6 ... ## $ age : int 69 64 38 63 65 49 69 68 43 70 ... ## $ prior : int 0 10 0 10 10 0 10 0 0 0 ... dd$treat &lt;- factor(dd$treat, labels = c(&quot;placebo&quot;, &quot;test&quot;)) dd$cellcode &lt;- factor(dd$cellcode, labels = c(&quot;squamous&quot;, &quot;small&quot;, &quot;adeno&quot;, &quot;large&quot;)) dd$censor &lt;- factor(dd$censor, labels = c(&quot;survival&quot;, &quot;dead&quot;)) dd$prior &lt;- factor(dd$prior, labels = c(&quot;no&quot;, &quot;yes&quot;)) head(dd) ## treat cellcode time censor diagtime kps age prior ## 1 placebo squamous 72 dead 60 7 69 no ## 2 placebo squamous 411 dead 70 5 64 yes ## 3 placebo squamous 228 dead 60 3 38 no ## 4 placebo squamous 126 dead 60 9 63 yes ## 5 placebo squamous 118 dead 70 11 65 yes ## 6 placebo squamous 10 dead 20 5 49 no str(dd) ## &#39;data.frame&#39;: 137 obs. of 8 variables: ## $ treat : Factor w/ 2 levels &quot;placebo&quot;,&quot;test&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ cellcode: Factor w/ 4 levels &quot;squamous&quot;,&quot;small&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ## $ time : int 72 411 228 126 118 10 82 110 314 100 ... ## $ censor : Factor w/ 2 levels &quot;survival&quot;,&quot;dead&quot;: 2 2 2 2 2 2 2 2 2 1 ... ## $ diagtime: int 60 70 60 60 70 20 40 80 50 70 ... ## $ kps : int 7 5 3 9 11 5 10 29 18 6 ... ## $ age : int 69 64 38 63 65 49 69 68 43 70 ... ## $ prior : Factor w/ 2 levels &quot;no&quot;,&quot;yes&quot;: 1 2 1 2 2 1 2 1 1 1 ... 5.3 類別變數 類別變數描述性統計主要是分析變數的 分配 或 分佈 (distribution), 分配敘述變數的觀測數值以及這些觀測數值出現的頻率. 類別變數描述性統計圖表常見為 頻率表 (frequency table), 長條圖 (bar plot) 與圓形圖 (pie chart). 對統計人員而言, 類別變數使用圓形圖呈現. 是非常不好的資料呈現方式, 使用頻率表 (Table) 或長條圖較佳. 5.3.1 單一類別變數 單一類別變數: 檢視類別水準的頻率大小. ## pie chart: ggplot2 do not have a simple geom_pie() ## use R base pie() cellcode.tab &lt;- table(dd$cellcode) cellcode.tab ## ## squamous small adeno large ## 35 48 27 27 prop.table(cellcode.tab) ## ## squamous small adeno large ## 0.2555 0.3504 0.1971 0.1971 round(prop.table(cellcode.tab), 3) ## ## squamous small adeno large ## 0.255 0.350 0.197 0.197 barplot(cellcode.tab) pie(cellcode.tab) library(ggplot2) ## bar chart ggplot(data = dd, aes(x = cellcode)) + geom_bar() ggplot(data = dd, aes(x = cellcode)) + geom_bar(fill = &quot;blue&quot;) + coord_flip() ggplot(data = dd, aes(y = cellcode)) + geom_bar(fill = &quot;red&quot;) # pie chart: no simple solution clar.freq &lt;- data.frame(cellcode.tab) names(clar.freq)[1] &lt;- &quot;cellcode&quot; clar.freq ## cellcode Freq ## 1 squamous 35 ## 2 small 48 ## 3 adeno 27 ## 4 large 27 ggplot(data = clar.freq, aes(x = &quot;&quot;, y = Freq, fill = cellcode)) + geom_bar(width = 1, stat = &quot;identity&quot;) + coord_polar(&quot;y&quot;, start = 0) ggplot(data = clar.freq, aes(x = &quot;&quot;, y = Freq, fill = cellcode)) + geom_bar(stat = &quot;identity&quot;, width = 1) + coord_polar(theta = &quot;y&quot;, start = 0) + theme_void() # remove background 5.3.2 多類別變數 雙類別變數: 檢視變數聯合水準的頻率大小, 檢視條件水準的頻率大小. ## two categorical vtriables table(dd$treat) ## ## placebo test ## 69 68 table(dd$cellcode) ## ## squamous small adeno large ## 35 48 27 27 twoway.tab &lt;- table(dd$treat, dd$cellcode) twoway.tab ## ## squamous small adeno large ## placebo 15 30 9 15 ## test 20 18 18 12 ## # cell proportion cell.prop &lt;- prop.table(twoway.tab, margin = NULL) round(cell.prop, 3) ## ## squamous small adeno large ## placebo 0.109 0.219 0.066 0.109 ## test 0.146 0.131 0.131 0.088 ## conditional on row sum to 1 cond_row_prop &lt;- prop.table(twoway.tab, margin = 1) round(cond_row_prop, 3) ## ## squamous small adeno large ## placebo 0.217 0.435 0.130 0.217 ## test 0.294 0.265 0.265 0.176 apply(cond_row_prop, 1, sum) # rows sum to 1 ## placebo test ## 1 1 ## conditional on column sum to 1 cond_col_prop &lt;- prop.table(twoway.tab, margin = 2) round(cond_col_prop, 3) ## ## squamous small adeno large ## placebo 0.429 0.625 0.333 0.556 ## test 0.571 0.375 0.667 0.444 apply(cond_col_prop, 2, sum) # cols sum to 1 ## squamous small adeno large ## 1 1 1 1 ## side-by-side bar plot barplot(twoway.tab, beside = TRUE, main = &quot;treat By cellcode&quot;, xlab = &quot;cell type&quot;) # Stacked Bar Plot barplot(twoway.tab, beside = FALSE, main = &quot;treat By cellcode&quot;, xlab = &quot;cell type&quot;) ## ggplot2 ## Automatically stack library(ggplot2) ggplot(data = dd, aes(x = cellcode, fill = treat)) + geom_bar() ggplot(data = dd, aes(x = cellcode, fill = treat)) + geom_bar(position = &quot;stack&quot;) ## side-by-side ggplot(data = dd, aes(x = cellcode, fill = treat)) + geom_bar(position = &quot;dodge&quot;) ggplot(data = dd, aes(x = cellcode, fill = treat)) + geom_bar(position = &quot;fill&quot;) 5.4 連續變數 連續變數描述性統計主要是分析變數的 分配 或 分佈 (distribution), 分配敘述變數的觀測數值以及這些觀測數值出現的頻率. 連續變數描述性統計圖表常見為 點狀圖 (dot plot), 枝葉圖 (stem-and-leaf), 次數分配表, 直方圖 (histogram), 盒鬚圖 (box plot), 密度圖 (density plot), 平均值, 變異數等. 對連續變數的描述, 若樣本數較少, 常使用點狀圖或枝葉圖. 目前多數為大數據, 點狀圖或枝葉圖較少使用, 但在實驗設計的數據呈現仍然非常重要. 5.4.1 單連續變數 單連續變數: 檢視中央趨勢, 離散程度 偏度, 峰度. ## use R base pie() ## histogram hist(dd$time, freq = TRUE, main = &quot;time histogram&quot;, xlab = &quot;time&quot;) hist(dd$time, freq = FALSE, main = &quot;time histogram&quot;, xlab = &quot;time&quot;) # box plot boxplot(dd$time, xlab = &quot;time&quot;) # QQ plot qqnorm(dd$time, main = &quot;Normal QQ Plot: time&quot;) # density plot plot(density(dd$time), pch = 16, main = &quot;Density Plot&quot;, xlab = &quot;time&quot;, ylab = &quot;density&quot;) ## ggplot2 ## histogram ggplot(data = dd, aes(x = time)) + geom_histogram() ## box plot ggplot(dd, aes(x = &quot;&quot;, y = time)) + geom_boxplot() ## violin plot ggplot(dd, aes(x = &quot;&quot;, y = time)) + geom_violin() ## density plot ggplot(data = dd, aes(x = time)) + geom_freqpoly() ggplot(data = dd, aes(x = time)) + stat_bin(geom = &quot;area&quot;) ggplot(data = dd, aes(x = time)) + stat_bin(geom = &quot;line&quot;) 5.4.2 二連續變數 散佈圖 scatter plot = X &amp; Y = 連續變數 雙連續變數: 檢視二個變數關聯性, 大小, 方向, 趨勢. ## R base ## scatter plot ## basic plot(x = dd$diagtime, y = dd$time) ## formulat y ~ x, data = data_name) plot(time ~ diagtime, data = dd) ## ggplot ggplot(data = dd, aes(x = diagtime, y = time)) + geom_point() ggplot(data = dd, aes(x = diagtime, y = time)) + geom_point(size = 5) ggplot(data = dd, aes(x = diagtime, y = time)) + geom_jitter() ggplot(data = dd, aes(x = diagtime, y = time)) + geom_jitter(size = 5, alpha = 1/2) ggplot(data = dd, aes(x = diagtime, y = time)) + geom_jitter(size = 5, alpha = 0.3) + geom_rug(col = &quot;steelblue&quot;, alpha = 0.1, size = 1.5) # add linear line or smoothing line ggplot(data = dd, aes(x = diagtime, y = time)) + geom_point() + geom_smooth(method = &quot;lm&quot;) ggplot(data = dd, aes(x = diagtime, y = time)) + geom_point() + geom_smooth(se = FALSE) ggplot(data = dd, aes(x = diagtime, y = time)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_smooth(se = FALSE) ## scatter plot + marginal distribution library(ggExtra) # classical p &lt;- ggplot(dd, aes(x = diagtime, y = time)) + geom_point() + theme(legend.position = &quot;none&quot;) # scatter plot + marginal histogram ggMarginal(p, type = &quot;histogram&quot;, color = &quot;purple&quot;) # scatter plot + marginal density ggMarginal(p, type = &quot;density&quot;) # scatter plot + marginal boxplot ggMarginal(p, type = &quot;boxplot&quot;) 5.5 混合變數 多變量視覺化分析 一連續 + 一類別 二連續 + 一類別 二類別 + 一連續 = 一連續 + 一類別 多變數 5.5.1 一連續 + 一類別 # one continuous + one categorical ggplot(data = dd, aes(x = time)) + geom_histogram(aes(fill = treat)) ggplot(data = dd, aes(x = time, fill = treat)) + geom_histogram( color = &quot;#e9ecef&quot;, alpha = 0.6, position = &#39;identity&#39;) ggplot(data = dd, aes(x = time, color = treat, fill = treat)) + geom_histogram() # ggplot(data = dd, aes(x = treat, y = time, fill = treat)) + geom_boxplot() ggplot(data = dd, aes(x = treat, y = time, fill = treat)) + geom_boxplot() + geom_jitter(color = &quot;purple&quot;, size = 2, alpha = 0.8) # ggplot(data = dd, aes(x = treat, y = time, fill = treat)) + geom_violin() ggplot(data = dd, aes(x = treat, y = time, fill = treat)) + geom_violin() + geom_jitter(color = &quot;purple&quot;, size = 2, alpha = 0.8) + ggtitle(&quot;Violin chart by treatment&quot;) + xlab(&quot;treatment&quot;) 5.5.2 二連續 + 一類別 ## ggplot2 ## two continuous + one categorical ggplot(data = dd, aes(x = diagtime, y = time, color = treat)) + geom_point(size = 4) ggplot(data = dd, aes(x = diagtime, y = time, color = treat)) + geom_jitter(size = 4) ggplot(data = dd, aes(x = diagtime, y = time, color = treat, shape = treat)) + geom_jitter(alpha = 1/2) # add linear line or smoothing line ggplot(data = dd, aes(x = diagtime, y = time, color = treat, shape = treat)) + geom_point() + geom_smooth(method = &quot;lm&quot;) ggplot(data = dd, aes(x = diagtime, y = time, color = treat, shape = treat)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) # ggplot(data = dd, aes(x = diagtime, y = time, color = treat, shape = treat)) + geom_point() + geom_smooth(se = FALSE) # BAD! too many lines ggplot(data = dd, aes(x = diagtime, y = time, color = treat, shape = treat)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_smooth(se = FALSE) # classical p &lt;- ggplot(dd, aes(x = diagtime, y = time, color = treat)) + geom_point(size = 5) # scatter plot + marginal histogram ggExtra::ggMarginal(p, type = &quot;histogram&quot;, color = &quot;purple&quot;) 5.5.3 三連續變數 多連續變數: 檢視成對變數關聯性, 大小, 方向, 趨勢. ## pairwise scatter plot ## R base con.df = dd[, c(&quot;time&quot;, &quot;diagtime&quot;, &quot;kps&quot;, &quot;age&quot;)] cor.mat = cor(con.df, use = &quot;complete&quot;, method = &quot;pearson&quot;) round(cor.mat, 3) ## time diagtime kps age ## time 1.000 0.382 -0.046 -0.068 ## diagtime 0.382 1.000 -0.184 -0.095 ## kps -0.046 -0.184 1.000 -0.033 ## age -0.068 -0.095 -0.033 1.000 pairs(con.df) ## ggplot2 library(GGally) GGally::ggpairs(data = con.df) GGally::ggcorr(data = con.df, method = c(&quot;complete&quot;, &quot;pearson&quot;)) ## Correlogram library(corrgram) corrgram(x = dd, order = TRUE, lower.panel = panel.shade, upper.panel = panel.pie, text.panel = panel.txt, main = &quot;1. VA Lung Cancer Trial&quot;) corrgram(x = dd, order = TRUE, lower.panel = panel.ellipse, upper.panel = panel.pts, text.panel = panel.minmax, main = &quot;2. VA Lung Cancer Trial&quot;) corrgram(x = dd, order = NULL, lower.panel = panel.shade, upper.panel = NULL, text.panel = panel.txt, main = &quot;3. VA Lung Cancer Trial&quot;) Try by yourself! # more advanced my_fn &lt;- function(data, mapping, ...){ p &lt;- ggplot(data = data, mapping = mapping) + geom_point() + geom_smooth(method = loess, se = FALSE, fill = &quot;red&quot;, color = &quot;red&quot;, ...) + geom_smooth(method = lm, se = FALSE, fill = &quot;blue&quot;, color = &quot;blue&quot;, ...) p } GGally::ggpairs(data = con.df, lower = list(continuous = my_fn)) ## Bubble plot ggplot(data = dd, aes(x = diagtime, y = time, size = age)) + geom_point(alpha = 0.3) + scale_size(range = c(.1, 15), name = &quot;Age Bubbles&quot;) ggplot(data = dd, aes(x = diagtime, y = time, size = age)) + geom_point(alpha = 0.3) + scale_size(range = c(.1, 15), name = &quot;Age Bubbles&quot;) ggplot(data = dd, aes(x = diagtime, y = time, size = age, color = treat)) + geom_point(alpha = 0.3) + scale_size(range = c(.1, 24), name = &quot;&quot;) 5.6 分組繪圖 將資料依據組別分割成子資料集 將每個子資料集繪製在不同的圖格 將所有子資料集的圖格合併呈現 # plot by treat ggplot(data = dd, aes(x = diagtime, y = time)) + geom_jitter() + facet_grid(. ~ treat) ggplot(data = dd, aes(x = diagtime, y = time)) + geom_jitter() + facet_grid(treat ~ .) # plot by cellcode ggplot(data = dd, aes(x = diagtime, y = time)) + geom_jitter() + facet_grid(. ~ cellcode) # two factors ggplot(data = dd, aes(x = diagtime, y = time)) + geom_jitter() + facet_grid(treat ~ cellcode) "],
["basicfunctiuon.html", "Chapter 6 基本函式 6.1 函式語法 6.2 檢視的函式原始碼定義 6.3 數列函式 6.4 重複元素函式: rep() 6.5 算數函式 Arithmetic Computing Function 6.6 組合與階乘函式: choose() 與 factorial() 6.7 選擇資料函式: all(), any(), which() 6.8 排序函式 Ranking and Sorting 6.9 物件查看與強制轉換函式", " Chapter 6 基本函式 {R} 有許多 函式 (function), 函式是一種物件, 是指令的集合, 執行特定功能或運算工作的指令, 資料整理, 資料分析等, 透過函式, 擴展了 {R} 在程式語言的功能性與便利性. 函式內通常需輸入 引數 (argument). {R} 基本系統 (base) 提供了一部分常用函式, 而更多不同類型的函式, 則由許多不同的學者貢獻到 {R} 系統 (contribution) 中, 這些函數都是用 {R} 程式語言寫成的. 例如, 統計常用函式 mean(), var(), sd(), log() 等. 6.1 函式語法 一個函式內通常需輸入 引數 (argument) 或是 統計公式, 統計模型, (formals). 引數可以是一個以上, 有些引數一定要輸入, 稱為 必要引數 (required argument), 有些引數可以不用輸入, 稱為 自選引數 (optional argument), 另外一種引數則為 省略引數 (ellipsis argument) 這三種引可以同時存在一個函式內, 引數可以是數值, 文字, 資料框架或 {R} 的任何物件. 例如, 函式 log() 指令: log(x, base = exp(1)) log() 函式在 {R} 內設以自然數為底計算, 其中 x 為必備引數, 使用者必須自行輸入所要計算的數值作為引數值. 而 base = exp(1) 為選擇引數, 若使用者沒有輸入引數值, 函式 log() 內設以自然數 \\(e\\) 為底, 當然, 使用者可以更動底數的設定值, 例如更動為以 \\(2\\) 為底的獨度對數運算, log(x, base = 2). ## basic function x.vec = c(1:5) x.vec # show x.vec ## [1] 1 2 3 4 5 mean(x = x.vec) # function mean() calculate mean, return a scalar ## [1] 3 var(x = x.vec) # function mean() calculate variance ## [1] 2.5 sd(x.vec) # function mean() calculate standard deviation ## [1] 1.581 summary(x.vec) # summarized statistics ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1 2 3 3 4 5 log(x = x.vec) # take log for all elements in vector x.vec ## [1] 0.0000 0.6931 1.0986 1.3863 1.6094 ## log function x.vec &lt;- c(1, 2, 3, 4, 5) log(x = x.vec) ## [1] 0.0000 0.6931 1.0986 1.3863 1.6094 log(x = x.vec, base = 2) ## [1] 0.000 1.000 1.585 2.000 2.322 6.2 檢視的函式原始碼定義 {R} 函式的原始碼定義分成 S3 classes 函式 與 S4 classes 函式, 許多時候, 可以在 {R} 輸入函式名稱, 檢視 S3 classes 的函式. 例如, function.name(), 查看函式的原始碼內容與計算過程. 有時必須使用 methods(\"function.name\"), getAnywhere(\"function.name\"), stats:::function.name 例如, 指令提示符號下輸入 sd, 查看函式 sd 的計算過程與引數. ## methods() sd ## function (x, na.rm = FALSE) ## sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), ## na.rm = na.rm)) ## &lt;bytecode: 0x000000000cc32bb0&gt; ## &lt;environment: namespace:stats&gt; t ## function (x) ## UseMethod(&quot;t&quot;) ## &lt;bytecode: 0x000000001a307a80&gt; ## &lt;environment: namespace:base&gt; methods(t) ## [1] t,ANY-method t,CsparseMatrix-method t,dgCMatrix-method ## [4] t,dgeMatrix-method t,diagonalMatrix-method t,dppMatrix-method ## [7] t,dsCMatrix-method t,dspMatrix-method t,dsTMatrix-method ## [10] t,dsyMatrix-method t,dtpMatrix-method t,dtrMatrix-method ## [13] t,dtTMatrix-method t,indMatrix-method t,lgeMatrix-method ## [16] t,lspMatrix-method t,lsTMatrix-method t,lsyMatrix-method ## [19] t,ltpMatrix-method t,ltrMatrix-method t,ltTMatrix-method ## [22] t,Matrix-method t,ngeMatrix-method t,nspMatrix-method ## [25] t,nsTMatrix-method t,nsyMatrix-method t,ntpMatrix-method ## [28] t,ntrMatrix-method t,ntTMatrix-method t,pMatrix-method ## [31] t,RsparseMatrix-method t,sparseVector-method t,TsparseMatrix-method ## [34] t.data.frame t.default t.fractions* ## [37] t.gtable* t.trellis* t.ts* ## [40] t.vctrs_sclr* t.vctrs_vctr* ## see &#39;?methods&#39; for accessing help and source code methods(class = &quot;ts&quot;) ## [1] [ [&lt;- aggregate as.data.frame as_tibble ## [6] cbind coerce cycle diff diffinv ## [11] filter initialize kernapply lines Math ## [16] Math2 monthplot na.omit Ops plot ## [21] print show slotsFromS3 t time ## [26] window window&lt;- ## see &#39;?methods&#39; for accessing help and source code 若要檢視 S4 classes 的函式, 可以使用 showClass(\"function.namme\"), showMethods(\"function.namme\"), getMethod(\"function.namme\"), selectMethod(), existsMethod(), hasMethod(), removeClass(), removeMethod(), getClass(), getSlots(), slotNames(), slot(). 另外一種查看函式的原始碼內容與計算過程, 是下載原始碼使用文書處理軟體打開檔案檢視. download.packages(pkgs = &quot;package.name&quot;, destdir = &quot;C:/RData&quot;, type = &quot;source&quot;) 6.3 數列函式 {R} 有幾個產生數列的基本函式, 包含 :, sequence(), rep() 等. 6.3.1 數列函式: seq() 與 sequence() 在統計運算中, 常需要產生數列向量, 例如產生 [1,2,3,4,5], [1,3,5,7,9] 等等, 可以使用 函式 : (冒號), seq() 或 sequence() 等產生數列向量. ## : 1:5 ## [1] 1 2 3 4 5 5:1 ## [1] 5 4 3 2 1 - 1:3 ## [1] -1 0 1 2 3 數列函式 seq() 或 sequence() 的指令, 不受限只有整數, 可以任產生何實數數列. seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)), length.out = NULL, along.with = NULL, ...) from = 1 數列起始值 to = 1 數列結束值 by 數列每次增加值 length.out 數列長度 (元素數目) ## seq() seq(from = 1, to = 5, by = 0.5) ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 seq(1, 5, 0.5) ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 seq(1, 5, length = 3) ## [1] 1 3 5 seq(from = 0, to = 1, by = 0.1) ## [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 seq(from = 0, to = 2, by = 0.33) ## [1] 0.00 0.33 0.66 0.99 1.32 1.65 1.98 sequence(c(3, 4, 5)) ## [1] 1 2 3 1 2 3 4 1 2 3 4 5 6.4 重複元素函式: rep() 另一個與 seq() 類似的函式 rep(), 可以產生相同重複元素的向量. 向量指令與其中引數分別為: rep(x, times = 1, length.out = NA, each = 1) x 使用者想要相同重複元素的數值向量. times 數值向量 x 重複的次數. each 數值向量 x 的每個元素重複的次數. length.out = NA 數值向量 x 重複後的長度. ## rep() rep(0, times = 3) ## [1] 0 0 0 rep(1, 5) ## [1] 1 1 1 1 1 x.vec &lt;- c(4, 5, 6) rep(x.vec, times = 2) ## [1] 4 5 6 4 5 6 rep(x.vec, each = 2) ## [1] 4 4 5 5 6 6 rep(x.vec, each = 2, times = 3) ## [1] 4 4 5 5 6 6 4 4 5 5 6 6 4 4 5 5 6 6 rep(x.vec, times = c(2, 2, 2)) ## [1] 4 4 5 5 6 6 rep(x.vec, times = c(1, 2, 3)) ## [1] 4 5 5 6 6 6 rep(x.vec, each = 2, len = 4) # first 4 only. ## [1] 4 4 5 5 6.5 算數函式 Arithmetic Computing Function {R} 有許多內建的 算數函式 (arithmetic function), 包含指數, 對數, Gamma 函數, Beta 函數, 三角函數, 反三角函數, 雙曲函數, 反雙曲函數 等等. 算數函式 Arithmetic Computing Function 符號 定義 - 減法運算 (Substraction, can be unary or binary) + 加法運算 (Addition, can be unary or binary) ! 否定運算 (Unary not) * 乘法運算 (Multiplication, binary) / 除法運算 (Division, binary) ^ 指數乘冪運算 (Exponentiation, binary) %% 整數除法的餘數 (Modulus, binary) %/% 整數除法的商數 (Integer divide, binary) %*% 矩陣內積乘法 (Matrix product, binary) %o% 矩陣外積乘法 (Outer product, binary) %x% 矩陣 Kronecker 乘法 (Kronecker product, binary) %in% 配對運算 (Matching operator, binary, in model formulae: nesting) round(x, digits = 0) 設定小數位數 (數值會受到作業系統影響) signif(x, digits = 6) 設定實數列印出的小數位數 (數值會受到作業系統影響) trunc(x) 將 x 的小數截斷, 向 0 靠近 ceiling(x) 大於 x 的最小整數 floor(x) 小於 x 的最大整數 sign(x) 求 x 的正負值, 回傳 1, 0, 或 -1. abs(x) 求 x 的絕對值 sqrt(x) \\(\\sqrt{x}\\) exp(x) \\(e^x\\) expm1(x) 當 \\(\\vert x \\vert &lt;&lt; 1\\), 計算 \\(e^{x}-1\\) log(x) \\(\\log (x)\\) log10(x) \\(log_{10} (x)\\) log2(x) \\(\\log_2 (x)\\) logb(x, base = z) \\(\\log_z (x)\\) log1p(x) 當 \\(\\vert x \\vert &lt;&lt; 1\\), 計算 \\(\\log(1+x)\\) gamma(x) \\(\\Gamma (x) = (x-1)! = \\int_0^\\infty t^{(x-1)} \\exp (-t) d t\\) lgamma(x) \\(\\log_e [\\Gamma (x)]\\) beta(a, b) \\(B (a,b) = (\\Gamma (a) \\Gamma (b))\\,/\\, (\\Gamma(a+b))\\) $ = _0^1 t^{(a-1)} (1-t)^{(b-1)} d t$ lbeta(a, b) \\(\\log_e [B(a, b)]\\) digamma(x) \\(\\frac{d}{dx} \\log_e [\\Gamma (x)]\\) trigamma(x) \\(\\frac{d^2}{d x^2} \\log_e [\\Gamma (x)]\\) psigamma(x, deriv = 0) \\(\\frac{d^p}{d x^p} \\log_e [\\Gamma (x)]\\) sin(x) cos(x) tan(x) 三角函數 (trigonometric functions) asin(x) acos(x) atan(x) 反三角函數 (inverse functions) sinh(x) cosh(x) tanh(x) 雙曲函數 (hyperbolic functionsx) asinh(x) acosh(x) atanh(x) 反雙曲函數 (inverse hyperbolic functions) ## Arithmetic Computing ## rounding (x.vec &lt;- 0.5 + c(-2:2)) ## [1] -1.5 -0.5 0.5 1.5 2.5 round(x.vec) # IEEE rounding ## [1] -2 0 0 2 2 (y.vec &lt;- seq(-2, 2, by = 0.5)) ## [1] -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 2.0 (y.round &lt;- round(y.vec)) # IEEE rounding ## [1] -2 -2 -1 0 0 0 1 2 2 (y.trunc &lt;- trunc(y.vec)) ## [1] -2 -1 -1 0 0 0 1 1 2 (y.signif &lt;- signif(y.vec)) ## [1] -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 2.0 (y.ceil &lt;- ceiling(y.vec)) ## [1] -2 -1 -1 0 0 1 1 2 2 (y.floor &lt;- floor(y.vec)) ## [1] -2 -2 -1 -1 0 0 1 1 2 cbind(y.vec, y.round, y.trunc, y.signif, y.ceil, y.floor) ## y.vec y.round y.trunc y.signif y.ceil y.floor ## [1,] -2.0 -2 -2 -2.0 -2 -2 ## [2,] -1.5 -2 -1 -1.5 -1 -2 ## [3,] -1.0 -1 -1 -1.0 -1 -1 ## [4,] -0.5 0 0 -0.5 0 -1 ## [5,] 0.0 0 0 0.0 0 0 ## [6,] 0.5 0 0 0.5 1 0 ## [7,] 1.0 1 1 1.0 1 1 ## [8,] 1.5 2 1 1.5 2 1 ## [9,] 2.0 2 2 2.0 2 2 # (x.vec &lt;- 0.5 + c(-2:3)) ## [1] -1.5 -0.5 0.5 1.5 2.5 3.5 round(x.vec) # IEEE rounding ## [1] -2 0 0 2 2 4 (y.vec &lt;- seq(-2, 3, by = 0.5)) ## [1] -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 2.0 2.5 3.0 (y.round &lt;- round(y.vec)) # IEEE rounding ## [1] -2 -2 -1 0 0 0 1 2 2 2 3 (y.trunc &lt;- trunc(y.vec)) ## [1] -2 -1 -1 0 0 0 1 1 2 2 3 (y.signif &lt;- signif(y.vec)) ## [1] -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 2.0 2.5 3.0 (y.ceil &lt;- ceiling(y.vec)) ## [1] -2 -1 -1 0 0 1 1 2 2 3 3 (y.floor &lt;- floor(y.vec)) ## [1] -2 -2 -1 -1 0 0 1 1 2 2 3 cbind(y.vec, y.round, y.trunc, y.signif, y.ceil, y.floor) ## y.vec y.round y.trunc y.signif y.ceil y.floor ## [1,] -2.0 -2 -2 -2.0 -2 -2 ## [2,] -1.5 -2 -1 -1.5 -1 -2 ## [3,] -1.0 -1 -1 -1.0 -1 -1 ## [4,] -0.5 0 0 -0.5 0 -1 ## [5,] 0.0 0 0 0.0 0 0 ## [6,] 0.5 0 0 0.5 1 0 ## [7,] 1.0 1 1 1.0 1 1 ## [8,] 1.5 2 1 1.5 2 1 ## [9,] 2.0 2 2 2.0 2 2 ## [10,] 2.5 2 2 2.5 3 2 ## [11,] 3.0 3 3 3.0 3 3 # (y.vec &lt;- seq(-2, 3, by = 0.5)) ## [1] -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 2.0 2.5 3.0 y.vec[trunc(y.vec) != floor(y.vec)] ## [1] -1.5 -0.5 y.vec[round(y.vec) != floor(y.vec + 0.5)] ## [1] -1.5 0.5 2.5 # (z.vec &lt;- pi * 100 ^ (-1:3)) ## [1] 3.142e-02 3.142e+00 3.142e+02 3.142e+04 3.142e+06 round(z.vec, 3) ## [1] 3.100e-02 3.142e+00 3.142e+02 3.142e+04 3.142e+06 signif(z.vec, 3) ## [1] 3.14e-02 3.14e+00 3.14e+02 3.14e+04 3.14e+06 # ## sign() abs() sign(pi) # == 1 ## [1] 1 sign(-2:3)# -1 -1 0 1 1 1 ## [1] -1 -1 0 1 1 1 abs(-2:3) ## [1] 2 1 0 1 2 3 # ## log(), exp() calculation (x.vec &lt;- 1:3) ## [1] 1 2 3 log(exp(x.vec)) ## [1] 1 2 3 (y.vec &lt;- 10 ^ (x.vec)) ## [1] 10 100 1000 log10(y.vec) ## [1] 1 2 3 log10(1e7) # = 7 ## [1] 7 # ## options(digits, scipen) options(digits = 4, scipen = 0) z.vec &lt;- pi * 100^(-1:3) print(z.vec / 1000, digits = 4) ## [1] 3.142e-05 3.142e-03 3.142e-01 3.142e+01 3.142e+03 options(digits = 4, scipen = 100) print(z.vec / 1000, digits = 4) ## [1] 0.00003142 0.00314159 0.31415927 31.41592654 3141.59265359 # options(digits = 4, scipen = 100) x.vec &lt;- 100 ^ -(1 + 2 * 1:3) cbind( x = x.vec, log1px = log(1 + x.vec), log1p = log1p(x.vec), exp = exp(x.vec) - 1, expm1 = expm1(x.vec) ) ## x log1px log1p ## [1,] 0.00000100000000 0.000000999999499918 0.00000099999950 ## [2,] 0.00000000010000 0.000000000100000008 0.00000000010000 ## [3,] 0.00000000000001 0.000000000000009992 0.00000000000001 ## exp expm1 ## [1,] 0.000001000000499962 0.00000100000050 ## [2,] 0.000000000100000008 0.00000000010000 ## [3,] 0.000000000000009992 0.00000000000001 # options(digits = 4, scipen = 0) x.vec &lt;- 100^(-(1 + 2 * 1:3)) cbind( x = x.vec, log1px = log(1 + x.vec), log1p = log1p(x.vec), exp = exp(x.vec) - 1, expm1 = expm1(x.vec) ) ## x log1px log1p exp expm1 ## [1,] 1e-06 1.000e-06 1e-06 1.000e-06 1e-06 ## [2,] 1e-10 1.000e-10 1e-10 1.000e-10 1e-10 ## [3,] 1e-14 9.992e-15 1e-14 9.992e-15 1e-14 6.6 組合與階乘函式: choose() 與 factorial() {R} 內建的組合與階乘函式 choose(), lchoose(), factorial(), lfactorial(), 其用法類似. choose(n, k) = \\(\\binom{n}{k}\\) fractorial(x) = \\(x!\\) k 為正整數. x 與 n 為數值向量. factorial(), lfactorial() 回傳原始結果取對數值. ## combination ## choose() choose(n = 5, k = 2) ## [1] 10 log(choose(n = 5, k = 2)) ## [1] 2.303 lchoose(n = 5, k = 2) ## [1] 2.303 for (n in 0:5) print(choose(n, k = 0:n)) ## [1] 1 ## [1] 1 1 ## [1] 1 2 1 ## [1] 1 3 3 1 ## [1] 1 4 6 4 1 ## [1] 1 5 10 10 5 1 ## factorial factorial(x = 100) ## [1] 9.333e+157 log(factorial(x = 100)) ## [1] 363.7 lfactorial(x = 100) ## [1] 363.7 lfactorial(x = 10000) ## [1] 82109 factorial(x = c(1, 3, 5)) ## [1] 1 6 120 6.7 選擇資料函式: all(), any(), which() 函式 all(x) 與 any(x) 可以用來查看特定向量物件 obj.vec 的元素是否符合某些特定條件, 回傳邏輯純量 TRUE 或 FALSE. 函式 which() 查看特定向量物件 obj.vec 的元素是否符合某些特定條件, 然後回傳一個下標向量, 紀錄向量物件符合某些特定條件的元素位置. 函式指令 which.max() 與 which.min() 是函式指令 which() 的延伸. all(..., na.rm = FALSE) any(..., na.rm = FALSE) which(x, arr.ind = FALSE, useNames = TRUE) 其中 ... 為輸入向量物件的條件判斷. all(x) 與 any(x) 回傳一個純量 (scalar) 代表 TRUE 或 FALSE. 使用函式 all(x) 用來檢查邏輯向量 \\(\\mathbf{x}\\) 的所有元素是否都是 TRUE? 另一方面, 使用函式 any(x) 用來檢查 邏輯向量 \\(\\mathbf{x}\\) 的任一元素是否為 TRUE? 使用函式指令 which(x) 則回傳一個向量, 是邏輯向量 \\(\\mathbf{x}\\) 中的元素為 TRUE 所在的下標位置 (index). which(x) 可使用引數 arr.ind = TRUE 是當 \\(\\mathbf{x}\\) 為 array (matrix) 時, 回傳 array (matrix) 的下標位置. ## all(), any(), which() (x.vec &lt;- c(-1:2)) ## [1] -1 0 1 2 all(x.vec &gt; 0) ## [1] FALSE any(x.vec &gt; 0) ## [1] TRUE which(x.vec &gt; 0) ## [1] 3 4 which.max(x.vec) ## [1] 4 which.min(x.vec) ## [1] 1 # (x.mat &lt;- matrix(c(2, -1, -3, -1, 2, 4, -3, 4, 9), nrow = 3, byrow = T)) ## [,1] [,2] [,3] ## [1,] 2 -1 -3 ## [2,] -1 2 4 ## [3,] -3 4 9 all(x.mat &gt; 0) ## [1] FALSE any(x.mat &gt; 0) ## [1] TRUE which(x.mat &gt; 0) ## [1] 1 5 6 8 9 # which(x.mat %% 2 == 0) ## [1] 1 5 6 8 which(x.mat %% 2 == 0, arr.ind = TRUE) ## row col ## [1,] 1 1 ## [2,] 2 2 ## [3,] 3 2 ## [4,] 2 3 6.8 排序函式 Ranking and Sorting 在 {R} 中有數個與排序相關的函式, 如 rev(), sort(), order() 與 rank(). 常見之排序函式 函式 說明 rev(x) 將向量 \\(\\mathbf{x}\\) 元素反轉列出 (reverse order) rank(x) 向量 \\(\\mathbf{x}\\) 元素的對應排序 (returns the sample ranks of the values) 相同數值內設排序方式 ties.method = \"average\" sort(x) 向量 \\(\\mathbf{x}\\) 從小到大列出 (sort a vector or factor, partially) into ascending or descending order). order(x) 將向量 \\(\\mathbf{x}\\) 從小到大排序後的向量之元素 rev(x) sort(x, decreasing = FALSE, na.last = NA, ...) rank(x, na.last = TRUE, ties.method = c(&quot;average&quot;, &quot;first&quot;, &quot;last&quot;, &quot;random&quot;, &quot;max&quot;, &quot;min&quot;)) order(x, ..., na.last = TRUE, decreasing = FALSE, method = c(&quot;shell&quot;, &quot;radix&quot;)) 這些函式的共用引數為: 引數 x 為向量 \\(\\mathbf{x}\\). 引數 decreasing: decreasing = FALSE 為 {R} 內設從小到大排序. decreasing = TRUE 則從大到小排序. 引數 na.last: na.last = TRUE 為 {R} 內設將 NA 排序在最大. na.last = FALSE 為 {R} 內設將 NA 排序在最小. na.last = NA 為 {R} 內設將 NA 排除. 函式 rev(x) 回傳一個向量 \\(\\mathbf{z}\\), 是將向量 \\(\\mathbf{x}\\) 元素反轉. 函式 sort(x) 回傳一個向量 \\(\\mathbf{z}\\), 是將向量 \\(\\mathbf{x}\\) 的元素從小到大排序的結果列出. 函式 %使用函式指令 rank(x) 回傳一個向量 \\(\\mathbf{z}\\), 是將向量 \\(\\mathbf{x}\\) 每一個元素從小到大排序之後, \\(\\mathbf{x}\\) 元素之相對順序 (rank). \"average\": 相同數值都是回傳平均排序值. \"first\": 相同數值都是回傳依序由小到大不同排序值. \"last\": 相同數值都是回傳依序由大到小排序值. \"random\": 相同數值回傳隨機排序值. \"max\": 相同數值回傳最大排序值. \"min\": 相同數值回傳最小排序值. ## reverse, rank, sort and order ## rev(): reverse elements x.vec &lt;- c(7, 7, 7, 6, 10, 9, 9, 9, NA, 8) rev(x.vec) ## [1] 8 NA 9 9 9 10 6 7 7 7 ## sort(): from the smallest to the largest sort(x.vec) ## [1] 6 7 7 7 8 9 9 9 10 ## rank(): rank(x.vec, na.last = TRUE) ## [1] 3 3 3 1 9 7 7 7 10 5 rank(x.vec, na.last = FALSE) ## [1] 4 4 4 2 10 8 8 8 1 6 set.seed(1) rank(x.vec, ties.method = &quot;average&quot;) ## [1] 3 3 3 1 9 7 7 7 10 5 rank(x.vec, ties.method = &quot;first&quot;) ## [1] 2 3 4 1 9 6 7 8 10 5 rank(x.vec, ties.method = &quot;last&quot;) ## [1] 4 3 2 1 9 8 7 6 10 5 rank(x.vec, ties.method = &quot;random&quot;) ## [1] 2 3 4 1 9 7 8 6 10 5 rank(x.vec, ties.method = &quot;max&quot;) ## [1] 4 4 4 1 9 8 8 8 10 5 rank(x.vec, ties.method = &quot;min&quot;) ## [1] 2 2 2 1 9 6 6 6 10 5 ## order(): retrun index ## x.vec[] is the smallest one order(x.vec) ## [1] 4 1 2 3 10 6 7 8 5 9 x.vec[order(x.vec)] ## [1] 6 7 7 7 8 9 9 9 10 NA ## rank(): ties.method = &quot;average&quot; x &lt;- c(7, 9, 6, 7, 8, NA) sort(x, na.last = FALSE) ## [1] NA 6 7 7 8 9 rank(x, ties.method = &quot;average&quot;, na.last = TRUE) ## [1] 2.5 5.0 1.0 2.5 4.0 6.0 (x.ord &lt;- order(x, na.last = FALSE)) ## [1] 6 3 1 4 5 2 x[x.ord] # = sort(x) ## [1] NA 6 7 7 8 9 {R} 排序對缺失值 NA 處理要非常小心, 引數 na.last = TRUE 為 {R} 內設, 但在比較關係上, 對缺失值 NA 可有不同處理. 6.9 物件查看與強制轉換函式 {R} 的許多函式型式為 is.object(), 例如函式 is.na(), is.vector() 等, 可以用來查看某一特定物件是否屬於某一類別. {R} 的許多函式型式為 as.object(), 例如函式 as.vector(), as.matrix(() 等, 可以用來某強制轉換一特定物件到所指定的物件類別. ## is() and as() # vector x.vec &lt;- c(1 / 1, 1 / 2, 1 / 3, 1 / 4, 1 / 5) x.vec ## [1] 1.0000 0.5000 0.3333 0.2500 0.2000 is.vector(x.vec) ## [1] TRUE is.character(x.vec) ## [1] FALSE x.vec &lt;- as.character(x.vec) x.vec ## [1] &quot;1&quot; &quot;0.5&quot; &quot;0.333333333333333&quot; ## [4] &quot;0.25&quot; &quot;0.2&quot; ## b.df &lt;- as.data.frame(matrix(c(1:24), nrow = 6, byrow = T)) is.matrix(b.df) ## [1] FALSE b.mat &lt;- as.matrix(b.df) b.mat ## V1 V2 V3 V4 ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 ## [4,] 13 14 15 16 ## [5,] 17 18 19 20 ## [6,] 21 22 23 24 b.mat &lt;- as.vector(b.mat) b.mat ## [1] 1 5 9 13 17 21 2 6 10 14 18 22 3 7 11 15 19 23 4 8 12 16 20 24 "],
["basicstat.html", "Chapter 7 基本統計函式 7.1 敘述統計函式 7.2 類別資料表格函數 7.3 機率函式與亂數生成函式 7.4 隨機抽樣函式 sample()", " Chapter 7 基本統計函式 {R} 有許多統計函式, 可以對向量物件進行統計分析, {R} 內建所有常見的基礎敘述統計量, 例如累加與乘積函式, sum(), cumsum(), diff(), prod(), cumprod(); 樣本統計量函式, 例如, mean(), median(), var(), sd(), range(), min(), max(), quantile(), sample() 等. 使用 {R} 的統計函式進行資料分析時, 須可別注意缺失值, 若資料物件中有缺失值, 一些 {R} 的統計函式須另外做特別處裡, 可以對資料物件中的缺失值, 先使用函式 na.omit() 處理, 然後再進行資料分析, 例如, mean(na.omit(x)). 另外, 可使用統計函式內的通用引數, na.rm = T, 例如, mean(x, na.rm = T) 然後再進行資料分析, 對矩陣或資料框架物件做運算, 若資料物件中有缺失值, 常會有不可預期的結果必須小心. 基本統計函式 格式 說明 sum(x) 加總和 (scalar) \\(y = \\sum_i x_i\\) cumsum(x) 累計加總和 (vector) \\(z_j = \\sum_{i \\le j} x_i\\) diff(x) x[i+1]-x[i] \\(z_i = x_{i+1} - x_i\\) lag(x, k) x[i-k] \\(z_i = x_{i-k}\\), 對應 x[i] 回傳 x[i-k] lead(x, k) x[i+k] \\(z_i = x_{i+k}\\), 對應 x[i] 回傳 x[i+k] prod(x) 乘積 (product) \\(y = \\prod_i x_i\\) cumprod(x) 累計乘積 $z_j = _{i j} x_i mean(x) 平均值 (mean) \\(\\bar{x} = \\frac{1}{n} \\sum_i x_i\\)) median(x) 中位數 (median) \\(0.5\\) quantile, \\(50^{th}\\) percentile var(x) 變異數, 共變異數 \\(s^2 = \\frac{1}{n-1} \\sum_i (x_i - \\bar{x})^2\\) sd(x) 標準差 (SD) \\(s = \\sqrt{s^2}\\) range(x) 範圍 (range) \\((\\min (x), \\max (x))\\) min(x) 最小值 \\(\\min (x)\\) max(x) 最大值 \\(\\max (x)\\) quantile(x) 百分位數 fivenum(x) 五數摘要 (five-number summary) \\((\\min, Q_1, \\text{median}, Q_3, \\max)\\) sample(x) 隨機抽樣 random sample 7.1 敘述統計函式 {R} 內建一些基本敘述統計, 如計算平均值與變異等. z &lt;- range(x) 函式回傳一個向量, 二個元素 \\((\\min(x), \\max(x))\\); 極大值與極小值分別為 min(x), max(x); 求取百分位值可以用 quantile(), 如 quantile(x, probs = c(0.05, 0.25, 0.5, 0.75, 0.95). fivenum(x) 回傳 \\(\\mathbf{x}\\) 向量 \\((\\min, Q_1, \\text{median}, Q_3, \\max)\\). ## basic descriptive statistics x &lt;- seq(-2, 3, 0.3) x ## [1] -2.0 -1.7 -1.4 -1.1 -0.8 -0.5 -0.2 0.1 0.4 0.7 1.0 1.3 1.6 1.9 ## [15] 2.2 2.5 2.8 sum(x) ## [1] 6.8 cumsum(x) ## [1] -2.0 -3.7 -5.1 -6.2 -7.0 -7.5 -7.7 -7.6 -7.2 -6.5 -5.5 -4.2 -2.6 -0.7 ## [15] 1.5 4.0 6.8 diff(x) ## [1] 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.3 prod(x) ## [1] -0.7138 cumprod(x) ## [1] -2.00000 3.40000 -4.76000 5.23600 -4.18880 2.09440 -0.41888 -0.04189 ## [9] -0.01676 -0.01173 -0.01173 -0.01525 -0.02440 -0.04635 -0.10197 -0.25493 ## [17] -0.71381 mean(x) ## [1] 0.4 median(x) ## [1] 0.4 var(x) ## [1] 2.295 sd(x) ## [1] 1.515 range(x) ## [1] -2.0 2.8 min(x) ## [1] -2 max(x) ## [1] 2.8 ## quantile y &lt;- quantile(x, probs = c(0.05, 0.25, 0.5, 0.75, 0.95)) y ## 5% 25% 50% 75% 95% ## -1.76 -0.80 0.40 1.60 2.56 # IQR: inter-quantile range iqr = y[4] - y[2] iqr ## 75% ## 2.4 ## five numnber summary fivenum(x) ## [1] -2.0 -0.8 0.4 1.6 2.8 # missing values x[3] &lt;- NA x[7] &lt;- NA x ## [1] -2.0 -1.7 NA -1.1 -0.8 -0.5 NA 0.1 0.4 0.7 1.0 1.3 1.6 1.9 ## [15] 2.2 2.5 2.8 mean(x) ## [1] NA mean(na.omit(x)) ## [1] 0.56 mean(x, na.rm = T) ## [1] 0.56 var(x, na.rm = T) ## [1] 2.338 7.2 類別資料表格函數 在類別資料分析中, 常常會使用到 列聯表 (contingency table), 在 {R} 中, 一些函式用來製造或操作 列聯表 (contingency table), 例如, table(), xtabs(), as.table(), is.table(); ftable(), read.ftable(), wirte.ftable(); as.data.frame(); margin.table(), prop.table(), addmargins() 等. 除此之外, {R} 還有一些關於列聯表的套件, 例如, xtable, vcd**,reshape2,plyr,dplyr,tidyr,tidyverse等, 將資料產生或轉換成列聯表. {R} 本身有一些分析列聯表的函式, 也有許多許多流行病學的套件與函式, 對 **列聯表** 進行分析. 例如,Epi,epibasix,epiDisplay(之前為epicalc),epifit,epiR,epitools,RCOR,pROC` 等, 可以進行流行病學分析, 套件主要分析能力大至相同, 但各別套件仍有其特徵. 類別資料的輸入常見有 2 種型式, (a) 個別資料 (individual data, micro data, case data); (b) 聚集資料 (aggregated data, macro data, summarized data, ecological data). 個別資料內包含每一位 個體 (subject, individual), 研究者為目前的研究目的所蒐集的第一手資料, 記錄著每一為個體的測量值, 個別資料有時稱為 原始資料 (raw data, primary data, original data). 資料只有摘要之後的結果, 是由其他來源所得到的資料, 沒有每一位個體的比變數觀測值, 例如沒有每一位個體的性別, 年紀等觀測值, 這種整理分析候的資料有時稱為 二手資料 或 次級資料 (secondary data). 個別資料可以經過整理成為聚集資料形態, 但是, 若遺失每一位個體的測量值, 只有聚集資料, 則無法回復原來的個別資料. 因此, 研究盡量使用每一位個體的測量值, 但有些時候, 無法得到每一位個體的測量值, 若資料內全是類別變數, 則 個別資料 與 聚集資料 分析結論部會有差別, 但資料內若有連續變數如年紀, BMI 等, 將連續變數轉換成類別變數, 只呈現或分析聚集資料, 則會造成所謂的 生態謬誤 (ecological fallacy), 是指由 聚集資料 (團體) 所得到的推論, 不能反應 個別資料 (個人的真實) 所得到的推論, 所產生研究推論的誤導. 7.2.1 列聯表函式: table(), xtabs() 使用函式 table(), xtabs(), 可以從任何向量, 矩陣, 陣列, 資料框架 創造一個列聯表, 回傳一個 列聯表 物件. 函式 table() 回傳的物件稱為 _contingency table_. 這是一個 {R} 物件類別 (class) 為 table 之特殊物件. 使用函式 as.table() 可用來強制將 矩陣 或 資料框架 形成列聯表物件. as.matrix() 強制將 列聯表物件 形成 矩陣. as.data.frame() 強制將 列聯表物件 形成 資料框架. as.data.frame() 是 xtabs() 的反函式. 使用函式 is.table() 可查看物件是否為列聯表物件. 使用函式 table() 須使用資料內個別變數或向量. 使用函式 xtabs() 可以從資料框架中, 利用統計模型公式 (model formula) 創造一個列聯表. 函式 as.data.frame() 則是函式 xtabs() 的反函式, 從列聯表物件創造一個資料框架. table(variable_name, ...) xtabs(formula, data) 其中常用引數如下. formula: 使用統計模型公式輸入. data: 資料框架名. na.action = \"na.omit\": 缺失值處理方式. exclude: 排除類別水準的細項, 自動內設排除缺失值. useNA: 處理缺失值選項. \"no\": 排除缺失值. \"ifany\": 納入缺失值, 若類別水準的計數 (count) 為正整數. \"always\": 永遠納入缺失值成為 1 類別水準. 即使類別水準的計數 (count) 為 0 仍然自成 1 個類別水準. Prentice (1973) 報告一個研究, 關於年長退伍軍人罹患肺癌, 且無法接受手術之臨床試驗, %病患在 Veteran’s Administration 醫院隨機接受標準治療或新的化學療法, 病患在榮民醫院隨機接受標準治療方法或新的化學治療方法, 比較治療的主要結果變數為死亡時間, 變數名稱列在表. 資料在檔案 survVATrial.csv. 變數 描述 treat (therapy) 治療組別: 0 = 標準; 1 = 新治療 cellcode 細胞型態; 1 = 鱗狀細胞; 2 = 小細胞; 3 = 腺體細胞; 4 = 大細胞 time 存活時間, 診斷日期至死亡日期, 單位以日計 censor 設限狀態: 0 = 設限; 1 = 死亡 diagtime Karnofsky performance score, 診斷時身體狀態表現的分數 diagtime 診斷到隨機分配的時間, 以月計 age 診斷時的年齡 (以年計) prior 先前是否接受治療; 0 = 無; 1 = 有 dd &lt;- read.table(&quot;./Data/survVATrial.csv&quot;, header = TRUE, sep = &quot;,&quot;, quote = &quot;\\&quot;&#39;&quot;, dec = &quot;.&quot;, row.names = NULL, # col.names, as.is = TRUE, # as.is = !stringsAsFactors, na.strings = c(&quot;.&quot;, &quot;NA&quot;)) head(dd) ## treat cellcode time censor diagtime kps age prior ## 1 0 1 72 1 60 7 69 0 ## 2 0 1 411 1 70 5 64 10 ## 3 0 1 228 1 60 3 38 0 ## 4 0 1 126 1 60 9 63 10 ## 5 0 1 118 1 70 11 65 10 ## 6 0 1 10 1 20 5 49 0 str(dd) ## &#39;data.frame&#39;: 137 obs. of 8 variables: ## $ treat : int 0 0 0 0 0 0 0 0 0 0 ... ## $ cellcode: int 1 1 1 1 1 1 1 1 1 1 ... ## $ time : int 72 411 228 126 118 10 82 110 314 100 ... ## $ censor : int 1 1 1 1 1 1 1 1 1 0 ... ## $ diagtime: int 60 70 60 60 70 20 40 80 50 70 ... ## $ kps : int 7 5 3 9 11 5 10 29 18 6 ... ## $ age : int 69 64 38 63 65 49 69 68 43 70 ... ## $ prior : int 0 10 0 10 10 0 10 0 0 0 ... dd$treat &lt;- factor(dd$treat, labels = c(&quot;placebo&quot;, &quot;test&quot;)) dd$cellcode &lt;- factor(dd$cellcode, labels = c(&quot;squamous&quot;, &quot;small&quot;, &quot;adeno&quot;, &quot;large&quot;)) dd$censor &lt;- factor(dd$censor, labels = c(&quot;survival&quot;, &quot;dead&quot;)) dd$prior &lt;- factor(dd$prior, labels = c(&quot;no&quot;, &quot;yes&quot;)) head(dd) ## treat cellcode time censor diagtime kps age prior ## 1 placebo squamous 72 dead 60 7 69 no ## 2 placebo squamous 411 dead 70 5 64 yes ## 3 placebo squamous 228 dead 60 3 38 no ## 4 placebo squamous 126 dead 60 9 63 yes ## 5 placebo squamous 118 dead 70 11 65 yes ## 6 placebo squamous 10 dead 20 5 49 no str(dd) ## &#39;data.frame&#39;: 137 obs. of 8 variables: ## $ treat : Factor w/ 2 levels &quot;placebo&quot;,&quot;test&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ cellcode: Factor w/ 4 levels &quot;squamous&quot;,&quot;small&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ## $ time : int 72 411 228 126 118 10 82 110 314 100 ... ## $ censor : Factor w/ 2 levels &quot;survival&quot;,&quot;dead&quot;: 2 2 2 2 2 2 2 2 2 1 ... ## $ diagtime: int 60 70 60 60 70 20 40 80 50 70 ... ## $ kps : int 7 5 3 9 11 5 10 29 18 6 ... ## $ age : int 69 64 38 63 65 49 69 68 43 70 ... ## $ prior : Factor w/ 2 levels &quot;no&quot;,&quot;yes&quot;: 1 2 1 2 2 1 2 1 1 1 ... ## one-way table ## table() table(dd$censor) ## ## survival dead ## 9 128 table(dd$cellcode) ## ## squamous small adeno large ## 35 48 27 27 ## xtabs() xtabs(~ censor, data = dd) ## censor ## survival dead ## 9 128 ## two-way table() ## table() dd.2tab = table(dd$cellcode, dd$censor) dd.2tab ## ## survival dead ## squamous 4 31 ## small 3 45 ## adeno 1 26 ## large 1 26 class(dd.2tab) ## [1] &quot;table&quot; ## xtabs() dd.2xtabs = xtabs(~ cellcode + censor, data = dd) dd.2xtabs ## censor ## cellcode survival dead ## squamous 4 31 ## small 3 45 ## adeno 1 26 ## large 1 26 class(dd.2xtabs) ## [1] &quot;xtabs&quot; &quot;table&quot; ## three-way table() ## table() dd.3tab = table(dd$treat, dd$censor, dd$cellcode) dd.3tab ## , , = squamous ## ## ## survival dead ## placebo 2 13 ## test 2 18 ## ## , , = small ## ## ## survival dead ## placebo 2 28 ## test 1 17 ## ## , , = adeno ## ## ## survival dead ## placebo 0 9 ## test 1 17 ## ## , , = large ## ## ## survival dead ## placebo 1 14 ## test 0 12 ## xtabs() dd.3xtabs = xtabs(~ treat + censor + cellcode, data = dd) dd.3xtabs ## , , cellcode = squamous ## ## censor ## treat survival dead ## placebo 2 13 ## test 2 18 ## ## , , cellcode = small ## ## censor ## treat survival dead ## placebo 2 28 ## test 1 17 ## ## , , cellcode = adeno ## ## censor ## treat survival dead ## placebo 0 9 ## test 1 17 ## ## , , cellcode = large ## ## censor ## treat survival dead ## placebo 1 14 ## test 0 12 7.2.2 列聯表函式: ftable() 函式 table() 或 xtabs() 對高維度列聯表的呈現類似 list 形式, 較不方便操作, 改使用函式 ftable(), 可以從任何向量, 矩陣, 陣列, 資料框架 創造一個 扁平列聯表 (flat contingency table), 扁平列聯表 是一個 ftalbe 類別 (class) 的矩陣物件, 其中變數 (欄位, column) 為分類因子變數, 另外再加上各組頻率數目, 每一列 (row) 代表每一種分類的類別水準 (level). 使用函式 ftable() 得到 ftable 物件, 在 {R} 的列印上, 會比 table() 或 xtabs() 得到 _contingency table_ 物件 好看. ## three-way table() ## ftable() dd.3ftab = ftable(dd$cellcode, dd$treat, dd$censor) dd.3ftab ## survival dead ## ## squamous placebo 2 13 ## test 2 18 ## small placebo 2 28 ## test 1 17 ## adeno placebo 0 9 ## test 1 17 ## large placebo 1 14 ## test 0 12 7.2.3 列聯表函式: margin.table(), prop.table() 使用函式 margin.table() 可以使用類別 (class) 為 table 的列聯表物件, 或是使用陣列型式 (array, matrix) 的列聯表物件 計算 邊際總合 (marginal total). 函式 prop.table() 從陣列型式 (array, matrix) 之列聯表物件, 計算列聯表物件的 相對頻率 (relative frequency). 函式 addmargins() 對列聯表物件進行邊際維度計算總和. 函式 margin.table() 與 函式 prop.table() 無法對 類別 (class) 為 ftable 的列聯表物件進行操作. 函式 addmargins() 可以對 類別 (class) 為 table 或 ftable 的列聯表物件進行操作. margin.table(x, margin = NULL) prop.table(x, margin = NULL) addmargins(A, margin, ...) 其中引數 x: table 物件. A: table 或 ftable 物件. margin: 維度下標或向量 (index/vector), 設定計算的邊際維度. margin = NULL: 計算列聯表內總和或個別空格分率 (cell count/proportion). margin = 1: 計算列聯表的列位 (row) 邊際總和或分率 (row marginal total/proportion). margin = 2: 計算列聯表的欄位 (column) 邊際總和或分率 (column marginal total/proportion). margin = k: 其餘維度則依此列推. ## one-way table ## table() dd.1tab = table(dd$cellcode) dd.1tab ## ## squamous small adeno large ## 35 48 27 27 margin.table(dd.1tab) ## [1] 137 prop.table(dd.1tab) ## ## squamous small adeno large ## 0.2555 0.3504 0.1971 0.1971 ## xtabs() dd.1xtabs = xtabs(~ censor, data = dd) margin.table(dd.1xtabs) ## [1] 137 prop.table(dd.1xtabs) ## censor ## survival dead ## 0.06569 0.93431 ## two-way table() ## table() dd.2tab = table(dd$cellcode, dd$censor) dd.2tab ## ## survival dead ## squamous 4 31 ## small 3 45 ## adeno 1 26 ## large 1 26 ## cell count total and proportion margin.table(dd.2tab) ## [1] 137 prop.table(dd.2tab) ## ## survival dead ## squamous 0.029197 0.226277 ## small 0.021898 0.328467 ## adeno 0.007299 0.189781 ## large 0.007299 0.189781 ## condition on row margin.table(dd.2tab, margin = 1) ## ## squamous small adeno large ## 35 48 27 27 prop.table(dd.2tab, margin = 1) ## ## survival dead ## squamous 0.11429 0.88571 ## small 0.06250 0.93750 ## adeno 0.03704 0.96296 ## large 0.03704 0.96296 ## condition on column margin.table(dd.2tab, margin = 2) ## ## survival dead ## 9 128 prop.table(dd.2tab, margin = 2) ## ## survival dead ## squamous 0.4444 0.2422 ## small 0.3333 0.3516 ## adeno 0.1111 0.2031 ## large 0.1111 0.2031 ## xtabs() dd.2xtabs = xtabs(~ cellcode + censor, data = dd) dd.2xtabs ## censor ## cellcode survival dead ## squamous 4 31 ## small 3 45 ## adeno 1 26 ## large 1 26 ## cell count total and proportion margin.table(dd.2xtabs) ## [1] 137 prop.table(dd.2xtabs) ## censor ## cellcode survival dead ## squamous 0.029197 0.226277 ## small 0.021898 0.328467 ## adeno 0.007299 0.189781 ## large 0.007299 0.189781 ## condition on row margin.table(dd.2xtabs, margin = 1) ## cellcode ## squamous small adeno large ## 35 48 27 27 prop.table(dd.2xtabs, margin = 1) ## censor ## cellcode survival dead ## squamous 0.11429 0.88571 ## small 0.06250 0.93750 ## adeno 0.03704 0.96296 ## large 0.03704 0.96296 ## condition on column margin.table(dd.2xtabs, margin = 2) ## censor ## survival dead ## 9 128 prop.table(dd.2xtabs, margin = 2) ## censor ## cellcode survival dead ## squamous 0.4444 0.2422 ## small 0.3333 0.3516 ## adeno 0.1111 0.2031 ## large 0.1111 0.2031 7.3 機率函式與亂數生成函式 {R} 具有詳盡的機率函式與亂數生成函式參見表 \\ref{tab:RDistFun**, 如令 \\(X\\) 為一隨機變數 (random variable), 定義如下. \\[ \\begin{aligned} &amp; f = f(X = x) = \\text{機率密度函數}\\; F(x) = \\int f(x) dx = \\text{累積機率分配函數}\\\\ p &amp; = F(q) = P (X \\le q) = \\text{累積機率分配函數, cumulative distribution function} \\\\ q &amp; = Q (u) = F^{-1} (p) = \\text{分位數函數, quantile function}, \\; \\text{其中}\\; p \\le P (X \\le q) \\\\ d &amp; = f(x) = F&#39; (x) = P (X = x) = \\text{機率密度分配函數, probability density function} \\\\ r &amp; = R (r) = f^{-1} (x) = \\text{隨機亂數函數, random number}, \\end{aligned} \\] 在 {R} 中, 相同的機率函數 (probability function), 使用相同的機率名稱, ProbFun, 在機率名稱, ProbFun, 之間, 加上 4 種不同的小寫字母, p, q, d, r, 產生不同的機率函式. 例如, fProbFun, 表示用相同的機率函式定義, 產生上述不同之結果. 非中央參數 (non-centrality parameter), ncp 現在僅用於累積分配函數, 此外還有函是 ptukey() 和 qtukey() 計算 Studentized Range Distribution. 機率函式 機率分配 {R} 函式名 (ProbFun) 引數 beta beta shape1, shape2, ncp binomial binom size, prob Cauchy cauchy location, scale chi-squared chisq df, ncp exponential exp rate F f df1, df1, ncp gamma gamma shape, scale geometric geom prob hypergeometric hyper m, n, k log-normal lnorm meanlog, sdlog logistic logis location, scale negative binomial nbinom normal norm mean, sd Poisson pois lambda Student’s t t df, ncp uniform unif min, max Weibull weibull shape, scale Wilcoxon wilcox m, n p 表示 累積機率分配函數 (cumulative distribution function, CDF). q 表示 分位數 (quantile), 符合 \\(u \\le P (X &lt; = x)\\) 的最小 \\(x\\). d 表示 機率密度函數 (probability density function, pdf). r 表示隨機模擬 偽隨機亂數, 隨機亂數 生成函式 (pseudo-random number generation function, random number). dProbFun 的第一個參數是 \\(x\\). pProbFun 的第一個參數是 \\(q\\). qProbFun 的第一個參數是 \\(p\\). rProbFun 的的第一個參數是 \\(n\\), 生成亂數之數目. pProbFun 和 qProbFun 函數 都有邏輯引數 lower.tail** 和log.p`. 若 lower.tail = TRUE (default), 機率計算為 \\(P (X &lt; = x)\\). 若 lower.tail = FALSE 機率計算為 \\(P (X &gt; x)\\). 若 log.p = TRUE, 機率 \\(p\\) 是以 log(p) 輸入與輸出. dProbFun 也有一個邏輯引數 log, 用來計算所要的對數機率值. # normal distribution pnorm(1.96) ## [1] 0.975 qnorm(0.975) ## [1] 1.96 dnorm(1.96) ## [1] 0.05844 # Poisson distribution rpois(10, 1) ## [1] 0 0 0 1 1 2 1 1 4 1 rpois(10, 2) ## [1] 3 4 1 2 0 1 1 0 1 4 rpois(10, 20) ## [1] 18 21 16 23 22 24 23 20 11 22 ## Cumulative distribution ## Pr(x &lt;= 2) ppois(2, 2) ## [1] 0.6767 ppois(4, 2) ## [1] 0.9473 ppois(6, 2) ## [1] 0.9955 # t distribution qt(0.995, df = 2) ## [1] 9.925 2*pt(-1.96, df = 2) ## [1] 0.1891 2*pt(-1.96, df = 30) ## [1] 0.05934 # upper 1% point for an F(1, 2) distribution sqrt(qf(0.99, 1, 2)) ## [1] 9.925 通常產生亂數序列希望是不會重復的, 實際上, {R} 在現在操作視窗下, 第一次產生時亂數時, 從當下時間 (current time), 生成一個 種子 (seed) 出發, 不斷迭代更新產生隨機均等分配亂數 (uniform random number), 所以不同時間下執行 {R}, 啟用不同的種子, 隨後內部的隨機種子就已經改變了, 模擬亂數是不會重復的, 有時我們需要模擬結果是可重復的亂數序列, 此時需要用函式 set.seed(), 在每次產生偽隨機亂數之前, 把種子設定種子為某一特定正整數即可. ## generate random number ## set.seed(): set initial value ## Caution use set.seed() everytime! ## uniform runif(5) ## [1] 0.86121 0.43810 0.24480 0.07068 0.09947 runif(5) ## [1] 0.3163 0.5186 0.6620 0.4068 0.9129 set.seed(10) runif(5) ## [1] 0.50748 0.30677 0.42691 0.69310 0.08514 set.seed(10) runif(5) ## [1] 0.50748 0.30677 0.42691 0.69310 0.08514 # norm rnorm(5) ## [1] -0.7540 -0.6059 -0.1772 0.1706 0.2428 rnorm(5) ## [1] -0.1794 -0.6305 0.9787 0.2933 -0.3703 set.seed(10) rnorm(5) ## [1] 0.01875 -0.18425 -1.37133 -0.59917 0.29455 set.seed(10) rnorm(5) ## [1] 0.01875 -0.18425 -1.37133 -0.59917 0.29455 ## normal + uniform set.seed(10) runif(5) ## [1] 0.50748 0.30677 0.42691 0.69310 0.08514 rnorm(5) ## [1] -0.7540 -0.6059 -0.1772 0.1706 0.2428 set.seed(10) runif(5) ## [1] 0.50748 0.30677 0.42691 0.69310 0.08514 rnorm(5) ## [1] -0.7540 -0.6059 -0.1772 0.1706 0.2428 set.seed(10) rnorm(5) ## [1] 0.01875 -0.18425 -1.37133 -0.59917 0.29455 runif(5) ## [1] 0.6517 0.5677 0.1135 0.5959 0.3580 7.4 隨機抽樣函式 sample() 在 {R} 中有一個常用的隨機抽樣函式, sample(), 用法如下. 若要重覆出現相同的隨機樣本, 須設定起始的一個 種子 (seed). sample(x, size, replace = FALSE, prob = NULL) x 為一長度大於 1 的任意向量, 或是一個正整數. size = k 設定所要抽出之樣本數. prob 設定每一個個體被抽取之相對應機率或比率之向量, 若無設定值, 則每一個個體被抽取之相對應機率為相等. replace = FALSE 邏輯指令, 設定是否可重複抽取. ## random sampling letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; ## [19] &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; sample(letters, 5) ## [1] &quot;g&quot; &quot;j&quot; &quot;b&quot; &quot;m&quot; &quot;h&quot; sample(letters, 5) ## [1] &quot;n&quot; &quot;g&quot; &quot;f&quot; &quot;y&quot; &quot;v&quot; set.seed(1) sample(letters, 5) ## [1] &quot;y&quot; &quot;d&quot; &quot;g&quot; &quot;a&quot; &quot;b&quot; sample(letters, 5) ## [1] &quot;w&quot; &quot;k&quot; &quot;n&quot; &quot;r&quot; &quot;s&quot; set.seed(1) sample(letters, 5) ## [1] &quot;y&quot; &quot;d&quot; &quot;g&quot; &quot;a&quot; &quot;b&quot; sample(letters, 5) ## [1] &quot;w&quot; &quot;k&quot; &quot;n&quot; &quot;r&quot; &quot;s&quot; ## sampling 5 subjects from 10 subjects ## without or with replacement set.seed(1) x &lt;- 1:10 sample(x, size = 5, replace = FALSE) # (a) no resampling ## [1] 9 4 7 1 2 sample(x, size = 5, replace = TRUE) # (b) resampling ## [1] 7 2 3 1 5 # permutation set.seed(1) x &lt;- 1:10 sample(x, size = 10, replace = FALSE) # no resampling ## [1] 9 4 7 1 2 5 3 10 6 8 # equal probability set.seed(1) x &lt;- 1:10 sample(x, size = 5, replace = FALSE, prob = c(1:10)) ## [1] 9 8 6 2 10 sample(x, size = 5, replace = FALSE, prob = c(rep(1, 10) / 10.0)) ## [1] 10 1 7 6 2 # unequal rpobability set.seed(1) x &lt;- 1:10 (prob.rs = c(seq(1, 10) / sum(seq(1, 10)))) ## [1] 0.01818 0.03636 0.05455 0.07273 0.09091 0.10909 0.12727 0.14545 0.16364 ## [10] 0.18182 sum(prob.rs) ## [1] 1 sample(x, size = 5, replace = TRUE, prob = seq(1, 10)) ## [1] 9 8 7 3 9 在臨床試驗或實驗性研究, 通常需要產生隨機分組名單, 可利用 sample(), 依照不同隨機指派方法, 產生不同隨機分組名單. 若要重覆出現相同的隨機樣本, 須設定起始的一個 種子 (seed). ## clinical trials or experiments ## randomization ## random assign to two groups, total 20 subjects ## random assigning treatment groups ## 20 Bernoulli trials set.seed(1) sample(c(0, 1), size = 20, replace = TRUE) ## [1] 0 1 0 0 1 0 0 0 1 1 0 0 0 0 0 1 1 1 1 0 sample(2, size = 20, replace = TRUE) ## [1] 1 1 1 1 1 1 2 1 1 2 2 2 1 2 1 1 2 1 2 2 # random choose 10 subjects to group 1 set.seed(1) sample(20, size = 10, replace = FALSE) ## [1] 4 7 1 2 13 19 11 17 14 3 # block randomization # total 5 blocks, block size 4, choose 2 subjects to group 1 set.seed(1) replicate(5, sample(c(1:4), size = 2, replace = FALSE)) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 1 1 3 2 ## [2,] 3 2 3 2 3 "],
["basictidy.html", "Chapter 8 資料基本處理 8.1 資料輸入套件 readr 8.2 整潔資料 Tidy Data 8.3 Tibble 與 Data Frame 8.4 資料流動管道運算指令 Pipe 8.5 資料檢視函式 glimpse() 8.6 資料處裡 dplyr 套件 8.7 資料聯集與交集函式 8.8 資料合併函式", " Chapter 8 資料基本處理 tidyverse 套件系統 包含許多不同套件, 提供資料科學一些實用的函式. 包含 tidyverse 核心 ggplot2 視覺化分析. purrr 執行迴圈. tibble 增強資料框架. dplyr 資料處裡. tidyr 精簡資料, stringr 字串整理. readr 資料輸入. `forcats 處理類別變數 (factors). tidyverse 套件系統的其他關聯套件包含 資料輸入 import readxl 輸入 excel 關聯檔案. haven 輸入 SPSS, Stata 與 SAS 關聯檔案. jsonlite 輸入 JSON 關聯檔案. xml2 輸入 XML 關聯檔案. httr 輸入 web APIs 關聯檔案. rvest 輸入 web scraping 關聯檔案. DBI 輸入 關聯資料庫, 協同套件有 RSQLite, RPostgres 或 odbc. 資料處理 tidy/wrangle stringr 處理字串. lubridate 處理日期與時間. forcats 處理類別變數 (factors). hms 處理日期與時間. blob 處理二元資料儲存檔案. 程式寫作 program rlang 提供寫作核心語言與 tidyverse. magrittr 提供資料流動通道 %&gt;%. glue 提供字串合併. 建模 model broom 處理建模結果. modelr 偕同執行建模族. 8.1 資料輸入套件 readr tidyverse 套件系統中的 readr 套件提供一些方便資料輸入的函式. 包含 read_csv() 輸入 .csv 資料檔, read_excel 輸入 excel 資料檔, read_delim() 輸入不同分隔符號資料檔. 其中引數如下 (help(read_delim)). file = 路徑與檔名 delim = 分隔符號 quote = 視同分隔符號 (資料的文字變數值常放在雙引號中) escape_backslash = 預設 FALSE, 是否有逃脫符號 escape_double = 預設TRUE, 是否用引號符號作為逃脫符號 col_names = 設定變數名 (T 或 F) col_types = 設定變數的類型 na = 設定 NA 符號 comment = 設定注釋符號, 在注釋符號之後的文字不會被讀入 trim_ws = 去除變數值得空白 skip = 要跳過幾行 (row) 才開始讀入資料 n_max = 最大輸入行數 # .csv library(tidyverse) library(readr) dd &lt;- readr::read_csv(&quot;C:/RData/DMTKAInfMo.csv&quot;) print(dd, n = 5, width = Inf) ## # A tibble: 78 x 16 ## No age sex DM DMyr preAC prePC postAC postPC medication SIDE ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 67 0 0 10 120 160 140 180 0 0 ## 2 2 67 0 0 11 100 150 150 220 0 1 ## 3 3 72 1 0 4 150 200 120 150 2 0 ## 4 4 82 1 0 8 150 200 160 250 0 1 ## 5 5 73 1 0 3 85 110 140 200 0 0 ## PREKS POSKS ABS INFECT INFMO ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 56 92 1 0 0 ## 2 62 62 0 1 2 ## 3 60 94 1 0 0 ## 4 47 90 1 0 0 ## 5 44 88 0 0 0 ## # ... with 73 more rows # .xls library(readxl) dd &lt;- readxl::read_excel(&quot;C:/RData/DMTKAInfMo.xls&quot;) print(dd, n = 5, width = Inf) ## # A tibble: 78 x 16 ## No age sex DM DMyr preAC prePC postAC postPC medication SIDE ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 67 0 0 10 120 160 140 180 0 0 ## 2 2 67 0 0 11 100 150 150 220 0 1 ## 3 3 72 1 0 4 150 200 120 150 2 0 ## 4 4 82 1 0 8 150 200 160 250 0 1 ## 5 5 73 1 0 3 85 110 140 200 0 0 ## PREKS POSKS ABS INFECT I0FECTMO ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 56 92 1 0 0 ## 2 62 62 0 1 2 ## 3 60 94 1 0 0 ## 4 47 90 1 0 0 ## 5 44 88 0 0 0 ## # ... with 73 more rows 8.2 整潔資料 Tidy Data 統計計算可以進行分析的資料, 通常有一個的簡單的基本架構, 在 {R} 稱作 資料框架 (data frame). 資料框架是類似於在 SAS, STATA 等的 dataset 架構. 資料框架通常類似矩陣, 資料框架也類似矩形的 交叉列聯表 (cross table), 稱為 資料表 (** data table). 套件 tidverse 原始套件 tidy` 強調外部資料檔案必須符合 整潔資料** (tidy data) 方便操作. 整潔資料的基本要求特徵是 每個變數各自形成 1 欄 (縱行, row), 每個列 (橫列, row) 各自為一個觀測時間的測量. 例如, 每位個體只有觀測一次, 則每個列為一位個體的觀測值. 若每位個體有多次觀測時間點, 則一位個體一次觀測時間點的觀測值為一列, 一位個體或有多列的觀測值. 一個整潔資料的資料表包含以下重點. 一個檔案只用一張資料表 一張資料表 (EXCEL 的 sheet). 一個欄位 (縱行, Column) 只有一個變數, 同時有清楚的變數名. 若完整資料包含不同資料表, 則不同資料表要有索引 (inxex) 或指標變數 (id) 可進行關聯與串聯. Tidy Data: R for Data Science, Figure 12.1 整潔資料 指引主要提供研究者在輸入資料檔案時能夠遵循. 例如, 一些者常將 EXCEL 一張 sheel 內混合著原始資料, 分析結果與圖形. 也經常將二個變數放在同一個欄位, 二個變數簡單以 / 分隔. 例如檔案 DMTKAORI.xls. 若資料檔案不是整潔資料, 則需浩費學多時間清理, 甚至必須重新輸入到資料檔案. 8.3 Tibble 與 Data Frame tidyverse 系統中的 readr 套件輸入資料後, tidyverse 會儲存成 (tibble) 資料物件, 成為tbl_df, tbl 類型的資料物件, 主要是 tidyverse 系統會使用 tibble 套件進行操作. tibbles 資料物件與原有資料框架 data.frame 物件有相同的屬性外, 另外多了些讓 tidyverse 系統容易操作的屬性. 對初學者而言, 二者幾呼無任何差異. 若有 {R} base 函式無法操作 tibble 資料物件, 可使用 as.data.frame() 轉成 {R} base 的 data.frame 物件. 同樣, 若 tidyverse 系統函式無法操作的 data.frame 物件, 可用 ‵as_tibble()將data.frame物件 轉成tibbles` 資料物件. 以資料在檔案第 5 章的 survVATrial.csv 為例. ## data frame object dd &lt;- read.table(&quot;./Data/survVATrial.csv&quot;, header = TRUE, sep = &quot;,&quot;, quote = &quot;\\&quot;&#39;&quot;, dec = &quot;.&quot;, row.names = NULL, # col.names, as.is = TRUE, # as.is = !stringsAsFactors, na.strings = c(&quot;.&quot;, &quot;NA&quot;)) class(dd) ## [1] &quot;data.frame&quot; library(tibble) dd &lt;- as_tibble(dd) class(dd) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; tibble 套件的 tibble() 函式的使用如同 {R} base data.frame(). tibble() 函式可以使用 {R} base 不准使用的變數名. tibble 物件與 data.frame 物件的主要差別有 2 種情境. tibble 物件的顯示, print() 只用 10 rows, 變數 (columns) 只有納入符合視窗寬度的數目, 這對大數據檢視較為方便. 且顯示 str() 函式可呈現變數基本模式的類別. 可使用 n = k 顯示 \\(k\\) rows, width = Inf 顯示所有變數. 也可設定整區選項為 options(tibble.print_min = Inf), 顯示所有 rows, 以及 options(tibble.width = Inf) 顯示所有 columns. {R} base 多數容許使用部分物件名 (變數名), 但 tibble 物件無法使用部分變數名. 可能會對資深程式寫作人員些許困擾. 8.4 資料流動管道運算指令 Pipe tidyverse 系統中的 magrittr 套件提供一個非常實用的運算指令 %&gt;% 稱為 pipe, 管線, 管道 導管. 此運算符號, 可將函式與運算串聯, %&gt;% 左側通常是資料物件, 資料框架, 矩陣, 向量等, %&gt;% 右側通常是函式 fun_name(), 而 %&gt;% 左側資料自動為函式 fun_name() 內的第一個引數. 在 Unix/Linux 系統的各種指令可以運用 pipe 的方式串連執行, magrittr 套件提供類似的思維, 且資料流動從 %&gt;% 左測的資料送到 %&gt;%右側的函式執行運算, 可讓程式寫作符合文字書寫由左到右的思考邏輯. 使用pipe` 並不會改變程式的執行順序, 主要目的在於讓程式更容易寫作與閱讀, 降低程式寫作的錯誤與負擔. ## short and clean log(mean(c(1:10))) ## [1] 1.705 ## easily read x &lt;- c(1:10) x.mean &lt;- mean(x) log.mean &lt;- log(x.mean) log.mean ## [1] 1.705 ## pipe %&gt;% library(magrittr) c(1:10) %&gt;% mean() %&gt;% log() ## [1] 1.705 8.5 資料檢視函式 glimpse() 資料輸入到 {R} 後, 必須先檢視資料內容, 比對原始資料檔案是否正確讀入資料. 包含觀測值數目, 變數數目, 那些變數為辨識指標, 變數屬性, 那些變數為連續變數或類別變數, 類別變數屬性, 名目變數或是順序變數, 整理類別變數的類別水準名稱. 每個變數的缺失數目與頻率, 每個個體的缺失數目與頻率. 以資料在檔案第 5 章的 survVATrial.csv 為例. dd = dd %&gt;% as_tibble() print(dd, n = 5, width = Inf) ## # A tibble: 137 x 8 ## treat cellcode time censor diagtime kps age prior ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 0 1 72 1 60 7 69 0 ## 2 0 1 411 1 70 5 64 10 ## 3 0 1 228 1 60 3 38 0 ## 4 0 1 126 1 60 9 63 10 ## 5 0 1 118 1 70 11 65 10 ## # ... with 132 more rows 可以看到資料有 137 位個體, 8 個變數. 其中time, diagtime, kps, age 為連續變數. treat, cellcode, censor, prior 等為類別變數, 但類別變數以數字輸入, 需先設定成為類別變數. 以資料在檔案第 5 章的 survVATrial.csv 為例. dd$treat &lt;- factor(dd$treat, labels = c(&quot;placebo&quot;, &quot;test&quot;)) dd$cellcode &lt;- factor(dd$cellcode, labels = c(&quot;squamous&quot;, &quot;small&quot;, &quot;adeno&quot;, &quot;large&quot;)) dd$censor &lt;- factor(dd$censor, labels = c(&quot;survival&quot;, &quot;dead&quot;)) dd$prior &lt;- factor(dd$prior, labels = c(&quot;no&quot;, &quot;yes&quot;)) print(dd, n = 5, width = Inf) ## # A tibble: 137 x 8 ## treat cellcode time censor diagtime kps age prior ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 placebo squamous 72 dead 60 7 69 no ## 2 placebo squamous 411 dead 70 5 64 yes ## 3 placebo squamous 228 dead 60 3 38 no ## 4 placebo squamous 126 dead 60 9 63 yes ## 5 placebo squamous 118 dead 70 11 65 yes ## # ... with 132 more rows tidyverse 系統中的 tibble 套件提供一個檢視資料函式 `glimpse(), 類似 {R} base 的 str() 函式. ## R base str(dd) ## tibble [137 x 8] (S3: tbl_df/tbl/data.frame) ## $ treat : Factor w/ 2 levels &quot;placebo&quot;,&quot;test&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ cellcode: Factor w/ 4 levels &quot;squamous&quot;,&quot;small&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ## $ time : int [1:137] 72 411 228 126 118 10 82 110 314 100 ... ## $ censor : Factor w/ 2 levels &quot;survival&quot;,&quot;dead&quot;: 2 2 2 2 2 2 2 2 2 1 ... ## $ diagtime: int [1:137] 60 70 60 60 70 20 40 80 50 70 ... ## $ kps : int [1:137] 7 5 3 9 11 5 10 29 18 6 ... ## $ age : int [1:137] 69 64 38 63 65 49 69 68 43 70 ... ## $ prior : Factor w/ 2 levels &quot;no&quot;,&quot;yes&quot;: 1 2 1 2 2 1 2 1 1 1 ... ## glimpse() glimpse(dd) ## Rows: 137 ## Columns: 8 ## $ treat &lt;fct&gt; placebo, placebo, placebo, placebo, placebo, placebo, ... ## $ cellcode &lt;fct&gt; squamous, squamous, squamous, squamous, squamous, squa... ## $ time &lt;int&gt; 72, 411, 228, 126, 118, 10, 82, 110, 314, 100, 42, 8, ... ## $ censor &lt;fct&gt; dead, dead, dead, dead, dead, dead, dead, dead, dead, ... ## $ diagtime &lt;int&gt; 60, 70, 60, 60, 70, 20, 40, 80, 50, 70, 60, 40, 30, 80... ## $ kps &lt;int&gt; 7, 5, 3, 9, 11, 5, 10, 29, 18, 6, 4, 58, 4, 9, 11, 3, ... ## $ age &lt;int&gt; 69, 64, 38, 63, 65, 49, 69, 68, 43, 70, 81, 63, 63, 52... ## $ prior &lt;fct&gt; no, yes, no, yes, yes, no, yes, no, no, no, no, yes, n... 8.6 資料處裡 dplyr 套件 tidyverse 系統中的資料處裡 dplyr 套件, 有一些資料資料處裡常用函式. %&gt;% = pipe 指令 rename() = 變數 (column) 重新命名 filter() = 選擇個體或行位子集 (rows) arrange() = 依據變數值排序 select() = 選擇變數 (variables) 或欄位子集 (columns) mutate() = 變數轉換 sample_n() 與 sample_frac() = 隨機抽樣函式 distinct() 與 n_distinct() = 選出明顯不同個體 slice() = 利用橫列指標 (row index) 選出個體 (row) summarise() = 計算常見統計量 group_by() = 資料分組操作 %&gt;% = pipe 指令 這些函式的第 1 個引數為資料物件, 後續只用為變數名 (不加雙引號), 可以合併使用 group_by() 函式與 %&gt;% 指令. 8.6.1 選擇個體函式 filter() 資料常常需要依據納入與排除條件, 此時會依據變數值進行篩選. filter() 函式可協助選擇個體. 以資料在檔案第 5 章的 survVATrial.csv 為例, 選擇個體 treat 為 placebo, cellcode 為 large. ## filter() dd %&gt;% filter(treat == &#39;placebo&#39;, cellcode == &#39;large&#39;) ## # A tibble: 15 x 8 ## treat cellcode time censor diagtime kps age prior ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 placebo large 177 dead 50 16 66 yes ## 2 placebo large 162 dead 80 5 62 no ## 3 placebo large 216 dead 50 15 52 no ## 4 placebo large 553 dead 70 2 47 no ## 5 placebo large 278 dead 60 12 63 no ## 6 placebo large 12 dead 40 12 68 yes ## 7 placebo large 260 dead 80 5 45 no ## 8 placebo large 200 dead 80 12 41 yes ## 9 placebo large 156 dead 70 2 66 no ## 10 placebo large 182 survival 90 2 62 no ## 11 placebo large 143 dead 90 8 60 no ## 12 placebo large 105 dead 80 11 66 no ## 13 placebo large 103 dead 80 5 38 no ## 14 placebo large 250 dead 70 8 53 yes ## 15 placebo large 100 dead 60 13 37 yes 選擇個體 treat 為試驗藥組, age 大於 50, kps 小於或等於 7 dd %&gt;% filter(treat == &#39;test&#39;, age &gt; 50, kps &lt;= 7) ## # A tibble: 35 x 8 ## treat cellcode time censor diagtime kps age prior ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 test squamous 112 dead 80 6 60 no ## 2 test squamous 242 dead 50 1 70 no ## 3 test squamous 111 dead 70 3 62 no ## 4 test squamous 587 dead 60 3 58 no ## 5 test squamous 389 dead 90 2 62 no ## 6 test squamous 33 dead 30 6 64 no ## 7 test squamous 467 dead 90 2 64 no ## 8 test squamous 283 dead 90 2 51 no ## 9 test small 25 dead 30 2 69 no ## 10 test small 21 dead 20 4 71 no ## # ... with 25 more rows 8.6.2 依據變數值排序函式 arrange() 資料常常需要依據變數值排序, arrange() 函式內設依照變數在函式出現順序以及變數值由小到大排序. 若要變數值從由大到小排序, 可使用 desc() 函式. 例如, 以資料在檔案第 5 章的 survVATrial.csv 為例, 依照 age 由小到大排序, time 由大到小排序. 無論如何排序, 缺失值總是排在最後, 這須與 {R} base 的 order(), sort() 或 rank() 進行比較. ## arrange() dd %&gt;% arrange(age, desc(time)) ## # A tibble: 137 x 8 ## treat cellcode time censor diagtime kps age prior ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 placebo adeno 95 dead 80 4 34 no ## 2 placebo small 4 dead 40 2 35 no ## 3 test squamous 1 dead 50 7 35 no ## 4 test small 103 survival 70 22 36 yes ## 5 placebo large 100 dead 60 13 37 yes ## 6 test large 49 dead 30 3 37 no ## 7 placebo squamous 228 dead 60 3 38 no ## 8 placebo adeno 117 dead 80 2 38 no ## 9 placebo large 103 dead 80 5 38 no ## 10 test adeno 31 dead 80 3 39 no ## # ... with 127 more rows 8.6.3 選擇變數或欄位子集函式 select() 面對大數據時, 可能有成千上萬的變數, 但通常部不會使用到所有的變數, 選擇所需要的變數另組成分析子集, 可減少 RAM 的負擔並加速分析執行速度. 以資料在檔案第 5 章的 survVATrial.csv 為例, 選擇 treat, cellcode, censor 等變數. dd %&gt;% select(treat, cellcode, censor) ## # A tibble: 137 x 3 ## treat cellcode censor ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 placebo squamous dead ## 2 placebo squamous dead ## 3 placebo squamous dead ## 4 placebo squamous dead ## 5 placebo squamous dead ## 6 placebo squamous dead ## 7 placebo squamous dead ## 8 placebo squamous dead ## 9 placebo squamous dead ## 10 placebo squamous survival ## # ... with 127 more rows 8.6.4 變數轉換函式 mutate() 資料分析前常常需要變數進行轉換, 例如取對數轉換, 標準化, 也常將二個以上不同變數進行計算, 轉換成新變數, 例如計算 BMI (生體質量指數). 以資料在檔案第 5 章的 survVATrial.csv 為例, 對 time 取對數轉換, diagtime * age / 100. ## mutate() dd %&gt;% mutate( log_age = log(age), diag_age = diagtime * age / 100 ) ## # A tibble: 137 x 10 ## treat cellcode time censor diagtime kps age prior log_age diag_age ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 place~ squamous 72 dead 60 7 69 no 4.23 41.4 ## 2 place~ squamous 411 dead 70 5 64 yes 4.16 44.8 ## 3 place~ squamous 228 dead 60 3 38 no 3.64 22.8 ## 4 place~ squamous 126 dead 60 9 63 yes 4.14 37.8 ## 5 place~ squamous 118 dead 70 11 65 yes 4.17 45.5 ## 6 place~ squamous 10 dead 20 5 49 no 3.89 9.8 ## 7 place~ squamous 82 dead 40 10 69 yes 4.23 27.6 ## 8 place~ squamous 110 dead 80 29 68 no 4.22 54.4 ## 9 place~ squamous 314 dead 50 18 43 no 3.76 21.5 ## 10 place~ squamous 100 surviv~ 70 6 70 no 4.25 49 ## # ... with 127 more rows 8.6.5 隨機抽樣函式 sample_n() 與 sample_frac() 函式 sample_n() 與 sample_frac() 可以對資料進行隨機抽樣. 引數為 size = k 設定所要抽出之樣本數或分率. weight 抽取之相對應權重. 若無設定值, 則每一個個體被抽取之相對應權重相等. replace = FALSE 邏輯指令, 設定是否可重複抽取. 以資料在檔案第 5 章的 survVATrial.csv 為例, 由資料抽樣 5 位個體. ## sample_n() dd %&gt;% sample_n(size = 5, replace = FALSE) ## # A tibble: 5 x 8 ## treat cellcode time censor diagtime kps age prior ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 placebo adeno 12 dead 50 4 63 yes ## 2 test squamous 1 dead 50 7 35 no ## 3 placebo small 123 survival 40 3 55 no ## 4 test small 51 dead 30 87 59 yes ## 5 test squamous 242 dead 50 1 70 no dd %&gt;% sample_n(size = 5, replace = TRUE) ## # A tibble: 5 x 8 ## treat cellcode time censor diagtime kps age prior ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 placebo squamous 82 dead 40 10 69 yes ## 2 test squamous 231 survival 50 8 52 yes ## 3 test squamous 389 dead 90 2 62 no ## 4 placebo small 18 dead 30 4 60 no ## 5 test small 80 dead 50 17 71 no dd %&gt;% sample_frac(size = 0.1) ## # A tibble: 14 x 8 ## treat cellcode time censor diagtime kps age prior ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 test adeno 83 survival 99 3 57 no ## 2 placebo small 31 dead 75 3 65 no ## 3 test small 51 dead 30 87 59 yes ## 4 test large 52 dead 60 4 45 no ## 5 test squamous 15 dead 50 13 40 yes ## 6 placebo small 20 dead 30 5 65 no ## 7 test squamous 201 dead 80 28 52 yes ## 8 test squamous 999 dead 90 12 54 yes ## 9 test squamous 242 dead 50 1 70 no ## 10 placebo small 7 dead 50 7 72 no ## 11 placebo small 51 dead 60 1 67 no ## 12 test adeno 31 dead 80 3 39 no ## 13 placebo small 13 dead 60 4 56 no ## 14 placebo small 22 dead 60 4 68 no 8.6.6 選出明顯不同個體函式 distinct() 與 n_distinct() 資料常常重覆輸入的個體, 或是個體有重覆測量, distinct() 函式可以查詢多少明顯不同的個體, 使用引數 .keep_all = TRUE 可以保留所有變數. 函式 n_distinct() 計算明顯不同的個體數目, 使用引數 na.rm = FALSE 決定是否納入缺失值. ## distict() set.seed(1) df &lt;- tibble( x = sample(10, 100, rep = TRUE), y = sample(10, 100, rep = TRUE) ) df ## # A tibble: 100 x 2 ## x y ## &lt;int&gt; &lt;int&gt; ## 1 9 3 ## 2 4 10 ## 3 7 3 ## 4 1 1 ## 5 2 6 ## 6 7 6 ## 7 2 4 ## 8 3 9 ## 9 1 5 ## 10 5 1 ## # ... with 90 more rows nrow(df) ## [1] 100 nrow(distinct(df)) ## [1] 65 nrow(distinct(df, x, y)) ## [1] 65 distinct(df, x) ## # A tibble: 10 x 1 ## x ## &lt;int&gt; ## 1 9 ## 2 4 ## 3 7 ## 4 1 ## 5 2 ## 6 3 ## 7 5 ## 8 10 ## 9 6 ## 10 8 distinct(df, y) ## # A tibble: 10 x 1 ## y ## &lt;int&gt; ## 1 3 ## 2 10 ## 3 1 ## 4 6 ## 5 4 ## 6 9 ## 7 5 ## 8 7 ## 9 2 ## 10 8 distinct(df, x, .keep_all = TRUE) ## # A tibble: 10 x 2 ## x y ## &lt;int&gt; &lt;int&gt; ## 1 9 3 ## 2 4 10 ## 3 7 3 ## 4 1 1 ## 5 2 6 ## 6 3 9 ## 7 5 1 ## 8 10 6 ## 9 6 3 ## 10 8 2 # set.seed(1) x &lt;- sample(1:10, 1e5, rep = TRUE) length(x) ## [1] 100000 length(unique(x)) ## [1] 10 n_distinct(x) ## [1] 10 8.6.7 利用橫列指標選出個體函式 slice() slice() 為一系列函式可以利用橫列指標 (row index) 選出個體 (row). 包含 slice() slice_head() 選出資料最前端的個體 slice_last() 選出資料最末端的個體 slice_min() 選出資料變數值最小的個體 slice_max() 選出資料變數值最大的個體 slice_sample() 隨機選出個體 ## slice() set.seed(1) dd %&gt;% slice(1) ## # A tibble: 1 x 8 ## treat cellcode time censor diagtime kps age prior ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 placebo squamous 72 dead 60 7 69 no dd %&gt;% slice(1:3) ## # A tibble: 3 x 8 ## treat cellcode time censor diagtime kps age prior ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 placebo squamous 72 dead 60 7 69 no ## 2 placebo squamous 411 dead 70 5 64 yes ## 3 placebo squamous 228 dead 60 3 38 no dd %&gt;% slice(101:n()) ## # A tibble: 37 x 8 ## treat cellcode time censor diagtime kps age prior ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 test small 99 dead 85 4 62 no ## 2 test small 61 dead 70 2 71 no ## 3 test small 25 dead 70 2 70 no ## 4 test small 95 dead 70 1 61 no ## 5 test small 80 dead 50 17 71 no ## 6 test small 51 dead 30 87 59 yes ## 7 test small 29 dead 40 8 67 no ## 8 test adeno 24 dead 40 2 60 no ## 9 test adeno 18 dead 40 5 69 yes ## 10 test adeno 83 survival 99 3 57 no ## # ... with 27 more rows dd %&gt;% slice(-c(1:100)) ## # A tibble: 37 x 8 ## treat cellcode time censor diagtime kps age prior ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 test small 99 dead 85 4 62 no ## 2 test small 61 dead 70 2 71 no ## 3 test small 25 dead 70 2 70 no ## 4 test small 95 dead 70 1 61 no ## 5 test small 80 dead 50 17 71 no ## 6 test small 51 dead 30 87 59 yes ## 7 test small 29 dead 40 8 67 no ## 8 test adeno 24 dead 40 2 60 no ## 9 test adeno 18 dead 40 5 69 yes ## 10 test adeno 83 survival 99 3 57 no ## # ... with 27 more rows dd %&gt;% slice_head(n = 3) ## # A tibble: 3 x 8 ## treat cellcode time censor diagtime kps age prior ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 placebo squamous 72 dead 60 7 69 no ## 2 placebo squamous 411 dead 70 5 64 yes ## 3 placebo squamous 228 dead 60 3 38 no dd %&gt;% slice_tail(n = 3) ## # A tibble: 3 x 8 ## treat cellcode time censor diagtime kps age prior ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 test large 231 dead 70 18 67 yes ## 2 test large 378 dead 80 4 65 no ## 3 test large 49 dead 30 3 37 no dd %&gt;% slice_min(time, n = 3) ## # A tibble: 3 x 8 ## treat cellcode time censor diagtime kps age prior ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 test squamous 1 dead 20 21 65 yes ## 2 test squamous 1 dead 50 7 35 no ## 3 test small 2 dead 40 36 44 yes dd %&gt;% slice_max(time, n = 3) ## # A tibble: 3 x 8 ## treat cellcode time censor diagtime kps age prior ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 test squamous 999 dead 90 12 54 yes ## 2 test squamous 991 dead 70 7 50 yes ## 3 test squamous 587 dead 60 3 58 no dd %&gt;% slice_sample(n = 3) ## # A tibble: 3 x 8 ## treat cellcode time censor diagtime kps age prior ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 placebo large 250 dead 70 8 53 yes ## 2 test large 53 dead 60 12 66 no ## 3 placebo small 63 dead 50 11 48 no 8.6.8 計算常見統計量函式 summarise() 資料分析常常需要變數基本統計量, 例如, 計算個數, 平均值, 變異數等等. summarise() 函式可計算常見統計量, 期常用引數有 Center: mean(), median() Spread: var(), sd(), IQR(), mad(). range() Range: min(), max(), quantile() Position: first(), last(), nth() Count: n(), n_distinct() Logical: any(), all() 以資料在檔案第 5 章的 survVATrial.csv 為例, 對資料計算個數 n(), 對 age 計算平均值與標準差. ## summarise dd %&gt;% summarise( count = n(), age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE) ) ## # A tibble: 1 x 3 ## count age_mean age_sd ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 137 58.3 10.5 8.6.9 資料分組操作函式 group_by() 資料分析常常需要類別變數分組, 個別操作資料或進行計算統計量. 函式 group_by() 引數可放入類別變數, 然後分組進行相同資料分析. 以資料在檔案第 5 章的 survVATrial.csv 為例, 對試驗藥組與安慰劑組分別對 diagtime 計算計算平均值與標準差.. ## group_by() dd %&gt;% group_by(treat) %&gt;% summarise( diagtime_mean = mean(diagtime), diagtime_sd = sd(diagtime) ) ## # A tibble: 2 x 3 ## treat diagtime_mean diagtime_sd ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 placebo 59.2 18.7 ## 2 test 57.9 21.4 dd %&gt;% group_by(treat, cellcode) %&gt;% summarise( diagtime_mean = mean(diagtime), diagtime_sd = sd(diagtime) ) ## # A tibble: 8 x 4 ## # Groups: treat [2] ## treat cellcode diagtime_mean diagtime_sd ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 placebo squamous 57.3 17.9 ## 2 placebo small 54.8 17.7 ## 3 placebo adeno 58.9 24.2 ## 4 placebo large 70 15.1 ## 5 test squamous 63.5 22.3 ## 6 test small 51.4 21.5 ## 7 test adeno 57.7 21.7 ## 8 test large 58.8 18.8 8.6.10 多變數計算統計量函式 summarise_all() summarise() 函式只能分別對當一變數進行計算, 若要同時對許多變數進行相同操作, 可使用以下函式. summarise_all() 對每一個變數進行相同操作 summarise_each() 對每一個變數進行相同操作, 需加變數名 summarise_at() 對選出的變數進行相同操作 需加變數名 summarise_if() 對符合特定條件的變數進行相同操作 ## summarise_all() dd %&gt;% select(time, diagtime, kps, age) %&gt;% summarise_all(mean, na.rm = TRUE) ## # A tibble: 1 x 4 ## time diagtime kps age ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 122. 58.6 8.77 58.3 dd %&gt;% select(time, diagtime, kps, age) %&gt;% summarise_all(list(mean, sd), na.rm = TRUE) ## # A tibble: 1 x 8 ## time_fn1 diagtime_fn1 kps_fn1 age_fn1 time_fn2 diagtime_fn2 kps_fn2 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 122. 58.6 8.77 58.3 158. 20.0 10.6 ## # ... with 1 more variable: age_fn2 &lt;dbl&gt; dd %&gt;% summarise_each(list(mean, sd), time, age) # not so useful ## # A tibble: 1 x 4 ## time_fn1 age_fn1 time_fn2 age_fn2 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 122. 58.3 158. 10.5 dd %&gt;% summarise_at(c(&quot;time&quot;, &quot;age&quot;), mean, na.rm = TRUE) ## # A tibble: 1 x 2 ## time age ## &lt;dbl&gt; &lt;dbl&gt; ## 1 122. 58.3 dd %&gt;% summarise_at(vars(time, age), mean, na.rm = TRUE) ## # A tibble: 1 x 2 ## time age ## &lt;dbl&gt; &lt;dbl&gt; ## 1 122. 58.3 dd %&gt;% summarise_if(is.numeric, list(mean, sd), na.rm = TRUE) ## # A tibble: 1 x 8 ## time_fn1 diagtime_fn1 kps_fn1 age_fn1 time_fn2 diagtime_fn2 kps_fn2 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 122. 58.6 8.77 58.3 158. 20.0 10.6 ## # ... with 1 more variable: age_fn2 &lt;dbl&gt; 8.7 資料聯集與交集函式 若二組資料有相同的變數, 但可能僅有部分相同的個體, 可以利用二組資料聯集與交集操作選出個體. intersect(x, y) 選出 x 與 y 都存在的不同個體. union(x, y) 選出 x 與 y 存在的不同個體. setdiff(x, y) 選出存在 x 但不存在 y 的不同個體. 以資料在檔案第 5 章的 survVATrial.csv 為例, 隨機從前 10 位個體重覆抽取 7 位, 進行 2 次, 得到 2 組資料. ## set operation df &lt;- dd %&gt;% select(treat, cellcode, time, censor, age) %&gt;% mutate(id = 1:n()) %&gt;% filter(id &lt;= 10) df ## # A tibble: 10 x 6 ## treat cellcode time censor age id ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; ## 1 placebo squamous 72 dead 69 1 ## 2 placebo squamous 411 dead 64 2 ## 3 placebo squamous 228 dead 38 3 ## 4 placebo squamous 126 dead 63 4 ## 5 placebo squamous 118 dead 65 5 ## 6 placebo squamous 10 dead 49 6 ## 7 placebo squamous 82 dead 69 7 ## 8 placebo squamous 110 dead 68 8 ## 9 placebo squamous 314 dead 43 9 ## 10 placebo squamous 100 survival 70 10 set.seed(1) x &lt;- df %&gt;% sample_n(size = 7, replace = TRUE) y &lt;- df %&gt;% sample_n(size = 7, replace = TRUE) x ## # A tibble: 7 x 6 ## treat cellcode time censor age id ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; ## 1 placebo squamous 314 dead 43 9 ## 2 placebo squamous 126 dead 63 4 ## 3 placebo squamous 82 dead 69 7 ## 4 placebo squamous 72 dead 69 1 ## 5 placebo squamous 411 dead 64 2 ## 6 placebo squamous 82 dead 69 7 ## 7 placebo squamous 411 dead 64 2 y ## # A tibble: 7 x 6 ## treat cellcode time censor age id ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; ## 1 placebo squamous 228 dead 38 3 ## 2 placebo squamous 72 dead 69 1 ## 3 placebo squamous 118 dead 65 5 ## 4 placebo squamous 118 dead 65 5 ## 5 placebo squamous 100 survival 70 10 ## 6 placebo squamous 10 dead 49 6 ## 7 placebo squamous 100 survival 70 10 intersect(x, y) ## # A tibble: 1 x 2 ## treat treat ## &lt;fct&gt; &lt;fct&gt; ## 1 placebo placebo union(x, y) ## [[1]] ## [1] placebo placebo placebo placebo placebo placebo placebo ## Levels: placebo test ## ## [[2]] ## [1] squamous squamous squamous squamous squamous squamous squamous ## Levels: squamous small adeno large ## ## [[3]] ## [1] 314 126 82 72 411 82 411 ## ## [[4]] ## [1] dead dead dead dead dead dead dead ## Levels: survival dead ## ## [[5]] ## [1] 43 63 69 69 64 69 64 ## ## [[6]] ## [1] 9 4 7 1 2 7 2 ## ## [[7]] ## [1] 228 72 118 118 100 10 100 ## ## [[8]] ## [1] dead dead dead dead survival dead survival ## Levels: survival dead ## ## [[9]] ## [1] 38 69 65 65 70 49 70 ## ## [[10]] ## [1] 3 1 5 5 10 6 10 setdiff(x, y) ## # A tibble: 5 x 4 ## time censor age id ## &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; ## 1 314 dead 43 9 ## 2 126 dead 63 4 ## 3 82 dead 69 7 ## 4 72 dead 69 1 ## 5 411 dead 64 2 8.8 資料合併函式 資料經常儲存再不同檔案, 例如門診檔, 住院檔, 實驗室檔, 同一位個體常須使用個體辨識碼 (id) 或姓名 (names) 進行合併或清理. 用來連結不同資料的個體辨識碼或變數稱為 關鍵碼 或 所引鍵 (key), 多數為個體辨識碼, 當有時為時間, 日期, 文見編號等, 可能同時須使用 2 個變數才能成為單一辨識碼, 例如, 同時須使用醫院與院內病歷號, 避免不同個體在不同醫院卻有有相同的病歷號. tidyverse 系統的有許多 _join_(x, y) 函式可進行各種資料合併. 若 2 組資料包含一些相同變數, 盪不同觀測值, 此時必須小心處理. inner_join(x, y) 包函 x 與 y 都配對存在的 x 與 y 個體與變數 left_join(x, y) 包函所有 x 個體與變數且在 y 有配對存在的 y 個體與變數 right_join(x, y)包函所有 y 個體與變數且在 x 有配對存在的 x 個體與變數 full_join(x, y) 包函所有 x 與 y 的個體與變數資料 semi_join(x, y) 包函 x 在 y 有配對存在的 x 個體與變數 anti_join(x, y) 包函 x 在 y 無配對存在的 x 個體與變數 dplyr::_join 以資料在檔案第 5 章的 survVATrial.csv 為例, 隨機從前 10 位個體抽取 7 位, 進行 2 次, 得到 2 組資料 x 與 y. x 資料包函 id, treat, time,age.y資料包函id,cellcode,ceosor,age`. ## _join() set.seed(1) df &lt;- dd %&gt;% select(treat, cellcode, time, censor, age) %&gt;% mutate(id = 1:n()) %&gt;% filter(id &lt;= 10) x &lt;- df %&gt;% select(id, treat, time, age) %&gt;% sample_n(size = 7, replace = FALSE) %&gt;% arrange(id) y &lt;- df %&gt;% select(id, cellcode, censor, age) %&gt;% sample_n(size = 7, replace = FALSE) %&gt;% arrange(id) x ## # A tibble: 7 x 4 ## id treat time age ## &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; ## 1 1 placebo 72 69 ## 2 2 placebo 411 64 ## 3 3 placebo 228 38 ## 4 4 placebo 126 63 ## 5 5 placebo 118 65 ## 6 7 placebo 82 69 ## 7 9 placebo 314 43 y ## # A tibble: 7 x 4 ## id cellcode censor age ## &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 1 squamous dead 69 ## 2 2 squamous dead 64 ## 3 3 squamous dead 38 ## 4 5 squamous dead 65 ## 5 6 squamous dead 49 ## 6 7 squamous dead 69 ## 7 10 squamous survival 70 inner_join(x, y) ## # A tibble: 5 x 6 ## id treat time age cellcode censor ## &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; ## 1 1 placebo 72 69 squamous dead ## 2 2 placebo 411 64 squamous dead ## 3 3 placebo 228 38 squamous dead ## 4 5 placebo 118 65 squamous dead ## 5 7 placebo 82 69 squamous dead left_join(x, y) ## # A tibble: 7 x 6 ## id treat time age cellcode censor ## &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; ## 1 1 placebo 72 69 squamous dead ## 2 2 placebo 411 64 squamous dead ## 3 3 placebo 228 38 squamous dead ## 4 4 placebo 126 63 &lt;NA&gt; &lt;NA&gt; ## 5 5 placebo 118 65 squamous dead ## 6 7 placebo 82 69 squamous dead ## 7 9 placebo 314 43 &lt;NA&gt; &lt;NA&gt; right_join(x, y) ## # A tibble: 7 x 6 ## id treat time age cellcode censor ## &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; ## 1 1 placebo 72 69 squamous dead ## 2 2 placebo 411 64 squamous dead ## 3 3 placebo 228 38 squamous dead ## 4 5 placebo 118 65 squamous dead ## 5 7 placebo 82 69 squamous dead ## 6 6 &lt;NA&gt; NA 49 squamous dead ## 7 10 &lt;NA&gt; NA 70 squamous survival full_join(x, y) ## # A tibble: 9 x 6 ## id treat time age cellcode censor ## &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; ## 1 1 placebo 72 69 squamous dead ## 2 2 placebo 411 64 squamous dead ## 3 3 placebo 228 38 squamous dead ## 4 4 placebo 126 63 &lt;NA&gt; &lt;NA&gt; ## 5 5 placebo 118 65 squamous dead ## 6 7 placebo 82 69 squamous dead ## 7 9 placebo 314 43 &lt;NA&gt; &lt;NA&gt; ## 8 6 &lt;NA&gt; NA 49 squamous dead ## 9 10 &lt;NA&gt; NA 70 squamous survival semi_join(x, y) ## # A tibble: 5 x 4 ## id treat time age ## &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; ## 1 1 placebo 72 69 ## 2 2 placebo 411 64 ## 3 3 placebo 228 38 ## 4 5 placebo 118 65 ## 5 7 placebo 82 69 anti_join(x, y) ## # A tibble: 2 x 4 ## id treat time age ## &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; ## 1 4 placebo 126 63 ## 2 9 placebo 314 43 "],
["purrr.html", "Chapter 9 資料迭代處理 9.1 對資料變數欄位 (columns) 進行相同操作 9.2 對資料個體列位 (rows) 進行相同操作 9.3 依據條件進行變數轉換 9.4 {R} 資料物件操作函式: apply()", " Chapter 9 資料迭代處理 統計分析的第一步就是資料清理與資料處理, 通常可佔據整體統計分析的 70%-80% 時間. 資料清理包含同一個體重覆輸入觀測值, 錯誤輸入觀測值, 缺失值檢視與處理, 連續變數語類別變數的區分, 選取適當的個體, 資料排序與分組等等, {R} 有許多資料處理的函式與套件, 但是 {R} 資料儲存有許多不同類型與格式, 包含 向量, 矩陣, 陣列, 列表等, 且 {R} 個別函式與套件, 統計模型接受的資料類型與格式各不相同, 因此讓使用者容易混淆而造成困擾. {R} 提供 apply() 系列函式, 參見表 1. 功能強大, 但因接受的資料類型與格式各不相同, 讓初學者相當困惑. 套件 plyr, dplyr, reshape, reshape2, purrr, tidyr, tidyverse 等, 提供較 {R} 容易理解的資料處理函式, 但是計算速度有差異, 且經常更新與改名, 也讓初學者相當困惑. Output object Input object array data frame list nothing array apply . . . data frame . aggregate by . list sapply . lapply . replicates replicate . replicate . function arguments mapply mapply . Table 1: {R} 常見資料物件操作 apply() 函式 資料清理與整理, 以及變數轉換, 包含對同一資料的許多變數進行相同操作, 例如, 對所有連續變數計算平均值與標準差, 包含對同一資料的許多個體進行相同操作, 例如, 對所有個體計算 5 次考試成績的總分, 平均值與標準差等等. 這些通常須進行迴圈迭代運算. {R} 套件 plyr, dplyr, reshape, reshape2, purrr 等有多些函式可讓使用者方便進行相同操作. 以下以資料 糖尿病防治臨床試驗 進行實例說明. 糖尿病防治臨床試驗 一位研究者進行一個大型糖尿病防治的臨床試驗, 比較 標準治療 (standard) 與 實驗治療 (experimental) 對長期控制平穩的血糖 與 預防嚴重糖尿病腎病變的療效. 研究主要目的是分析長期控制平穩的血糖, 主要反應變數以測量糖化血色素 (HbA1c) 為代表, 研究的次要目的是預防嚴重糖尿病腎病變, 次要目的反應變數以是否出現 顯微蛋白尿 (microalbuminuris) 的時間為代表. 研究在臨床試驗開始時, 紀錄受試者的一些基本資料, 例如年紀, 性別等, 同時紀錄可能會影響結果的一些臨床測量, 例如, 臨床試驗開始時的 糖化血色素, 及受試者內生胰島素的 C-peptide 測量等. 研究資料在檔案 DMDCCThba1c6.csv, 變數說明在表 2. 變數 描述 id 受試者編碼, 依照進入試驗的時間順序而編碼. treat 治療組別: 0 = 傳統型治療; 1 = 加強型治療. etdrs0 試驗開始時視網膜病變嚴重程度指數: ETDRS grade. neur0 試驗開始時神經病變: 0 = 無; 1 = 有. aer0 試驗開始時蛋白尿測量: albumin excretion rate (mg/24 h). microalb 治療後是否出現顯微蛋白尿: 0 = 無; 1 = 有. quart 治療後出現顯微蛋白尿的追蹤時間的季數或最後追蹤時間, 單位: 季. (quarterly visit number). duration 治療後出現顯微蛋白尿的時間或最後追蹤的時間, 單位: 月. female 性別: 0 = 男性; 1 = 女性. age 試驗開始時的年紀, 單位: 年. adult 試驗開始時是否成年, 0 = \\(\\le 17\\), 1 = 是. cpeptide 試驗開始時, 受試者內生胰島素的 C-peptide 測量. bmi 試驗開始時的 BMI (身體質量指數). hba1c0 試驗開始時的 HBA1c 測量. hba1c1-hba1c6 治療後 1-6 年, 每年 HBA1c 測量. Table 2: 糖尿病防治臨床試驗變數說明 library(tidyverse) dd &lt;- readr::read_csv(&quot;C:/RData/DMDCCThba1c6.csv&quot;, na = c(&quot;.&quot;, &quot;&quot;, &quot;NA&quot;), trim_ws = TRUE) # glimpse(dd) dd$treat = factor(dd$treat, labels = c(&quot;placebo&quot;, &quot;test&quot;)) dd$neur0 = factor(dd$neur0, labels = c(&quot;no&quot;, &quot;yes&quot;)) dd$microalb = factor(dd$microalb, labels = c(&quot;no&quot;, &quot;yes&quot;)) dd$adult = factor(dd$adult, labels = c(&quot;no&quot;, &quot;yes&quot;)) dd$female = factor(dd$female, labels = c(&quot;male&quot;, &quot;female&quot;)) print(dd, n = 5, width = Inf) ## # A tibble: 1,441 x 21 ## id treat etdrs0 neur0 aer0 microalb quart duration female age ## &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 1 test 3 no 15.8 no 36 178 female 17 ## 2 2 placebo 8 no 11.5 yes 20 142 male 29 ## 3 3 placebo 7 yes 36 yes 12 175 male 35 ## 4 4 test 1 no 4.32 no 36 31 female 14 ## 5 5 test 2 no 7.2 no 36 72 male 32 ## adult cpeptide bmi hba1cbase hba1c0 hba1c1 hba1c2 hba1c3 hba1c4 hba1c5 ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 no 0.09 21.2 9.63 9.63 8.91 8.72 8.87 8.81 8.76 ## 2 yes 0.17 22.9 8.76 8.76 9.30 9.36 9.39 9.30 9.15 ## 3 yes 0.01 26.6 7.93 7.93 8.28 7.92 7.96 7.97 7.94 ## 4 no 0.18 16.2 7.62 7.62 8.65 8.75 8.88 8.85 8.82 ## 5 yes 0.03 26.3 8.53 8.53 7.04 7.40 7.49 7.72 7.83 ## hba1c6 ## &lt;dbl&gt; ## 1 8.62 ## 2 9.10 ## 3 7.95 ## 4 8.56 ## 5 7.81 ## # ... with 1,436 more rows 9.1 對資料變數欄位 (columns) 進行相同操作 {R} 套見 purrr 內函式群 map() 可對對同一資料的許多變數進行相同操作, 例如, 對所有連續變數計算平均值與標準差. 函式群 map() 包含 map() 回傳列表 list, 與 {R} base 函式 lapply() 類似. map_lgl() 回傳邏輯向量 logical vector. map_int() 回傳整數向量 integer vector. map_dbl() 回傳實數向量 double vector. map_chr() 回傳文字向量 character vector. map_df() 回傳資料框架 data.frame. 以 糖尿病防治臨床試驗 的 DMDCCThba1c6.csv 為例. 對連續變數 bia1c4 – hbac16 計算算平均值與標準差. dd.con &lt;- dd %&gt;% select(hba1c4:hba1c6) dd.con %&gt;% map(mean, na.rm = TRUE) ## $hba1c4 ## [1] 8.163 ## ## $hba1c5 ## [1] 8.183 ## ## $hba1c6 ## [1] 8.193 dd.con %&gt;% map_dbl(mean, na.rm = TRUE) ## hba1c4 hba1c5 hba1c6 ## 8.163 8.183 8.193 dd.con %&gt;% map_dbl(sd, na.rm = TRUE) ## hba1c4 hba1c5 hba1c6 ## 1.492 1.466 1.467 dd.con %&gt;% map_df(mean, na.rm = TRUE) ## # A tibble: 1 x 3 ## hba1c4 hba1c5 hba1c6 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 8.16 8.18 8.19 9.2 對資料個體列位 (rows) 進行相同操作 套見 dplyr 函式 mutate() 可以對資料個體列位 (rows) 進行相同操作, 產生新的變數與變數值, 但只能以向量進行操作, 若使用 {R} 函式, 有時無法接受向量, 有時無法產生向量. 此時可以使用 rowise() 函式, 對資料個體列位 (rows) 進行相同操作函式. 例如, 對所有個體計算 5 次考試成績的總分, 平均值與標準差等等. 以 糖尿病防治臨床試驗 的 DMDCCThba1c6.csv 為例. 對連續變數 bia1c4 – hbac16 計算算平均值與標準差. dd.con &lt;- dd %&gt;% select(hba1c4:hba1c6) dd.row_mean &lt;- dd.con %&gt;% rowwise %&gt;% mutate(hba1c_row_mean = mean(c(hba1c4, hba1c5, hba1c6), na.rm = TRUE)) print(dd.row_mean, n = 5) ## # A tibble: 1,441 x 4 ## # Rowwise: ## hba1c4 hba1c5 hba1c6 hba1c_row_mean ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 8.81 8.76 8.62 8.73 ## 2 9.30 9.15 9.10 9.18 ## 3 7.97 7.94 7.95 7.96 ## 4 8.85 8.82 8.56 8.74 ## 5 7.72 7.83 7.81 7.79 ## # ... with 1,436 more rows ## compare simple mutate dd.var_mean &lt;- dd.con %&gt;% mutate(hba1c_row_mean = mean(c(hba1c4, hba1c5, hba1c6), na.rm = TRUE)) print(dd.var_mean, n = 5) ## # A tibble: 1,441 x 4 ## hba1c4 hba1c5 hba1c6 hba1c_row_mean ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 8.81 8.76 8.62 8.18 ## 2 9.30 9.15 9.10 8.18 ## 3 7.97 7.94 7.95 8.18 ## 4 8.85 8.82 8.56 8.18 ## 5 7.72 7.83 7.81 8.18 ## # ... with 1,436 more rows 9.3 依據條件進行變數轉換 套見 dplyr 函式 mutate() 可以並用 函式 case_when, 當個體列位 (row) 的變數值符合特定條件時, 進行不同的變數轉換. df %&gt;% mutate( new_field = case_when(my_field == &quot;something&quot; ~ &quot;result&quot;, my_field != &quot;something else&quot; ~ &quot;other result&quot;, TRUE ~ &quot;all other results&quot;) ) 以 糖尿病防治臨床試驗 的 DMDCCThba1c6.csv 為例. 對順序變數 etdrs0 (試驗開始時視網膜病變嚴重程度指), 簡化成 3 組, mild, moderate, severe. dd.et &lt;- dd %&gt;% mutate( et0cat3 = case_when(etdrs0 &lt;= 2 ~ &quot;mild&quot;, etdrs0 &gt; 2 &amp; etdrs0 &lt;= 4 ~ &quot;moderate&quot;, TRUE ~ &quot;severe&quot;)) %&gt;% select(etdrs0, et0cat3) print(dd.et, n = 5) ## # A tibble: 1,441 x 2 ## etdrs0 et0cat3 ## &lt;dbl&gt; &lt;chr&gt; ## 1 3 moderate ## 2 8 severe ## 3 7 severe ## 4 1 mild ## 5 2 mild ## # ... with 1,436 more rows 9.4 {R} 資料物件操作函式: apply() 使用函式 apply() 對一個 資料框架 (data frame), 矩陣 (matrix) 陣列物件 (array) 內之任一維度的邊際 (margins of an array) 執行同一個函式運算, 並回傳一向量, 陣列或列表. 函式指令為 apply(X, MARGIN, FUN, ...) 其中的主要引數分別為: X 為所要執行之陣列物件, 若資料物件 X 為 矩陣 或 資料框架, 則函式 apply() 會將該 矩陣 或 資料框架 轉換成 2-維度 陣列 (array). MARGIN 為陣列物件 X 的邊際維度序號. MARGIN = 1 會對陣列 X 的第 1 個維度 (row) 執行函式, 例如, 對 矩陣 或 資料框架 的每一列 (row) 做運算. MARGIN = 2 會對陣列 X 的第 2 個維度 (column) 執行函式, 例如, 對 矩陣 或 資料框架 的每一欄 (行, column) 做運算等等. MARGIN = k 會對陣列 X 的第 \\(k\\)-維度 執行函式. FUN 為執行同一函式的名稱. 以 糖尿病防治臨床試驗 的 DMDCCThba1c6.csv 為例. 對連續變數 bia1c4 – hbac16 計算算平均值與標準差. dd.con &lt;- dd %&gt;% select(hba1c4:hba1c6) apply(dd.con, 2, mean, na.rm = TRUE) ## hba1c4 hba1c5 hba1c6 ## 8.163 8.183 8.193 以 糖尿病防治臨床試驗 的 DMDCCThba1c6.csv 為例. 對連續變數 bia1c4 – hbac16 計算算平均值與標準差. 個體列位 (row) 的 bia1c4 – hbac16 計算算平均值與標準差. dd.con &lt;- dd %&gt;% select(hba1c4:hba1c6) dd.row_mean &lt;- apply(dd.con, 1, mean, na.rm = TRUE) head(dd.row_mean) ## [1] 8.733 9.184 7.956 8.743 7.786 8.136 {R} 函式 colMeans() 與 rowMeans() 也可進行快速計算平均值. dd.con &lt;- dd %&gt;% select(hba1c4:hba1c6) colMeans(dd.con, na.rm = TRUE) ## hba1c4 hba1c5 hba1c6 ## 8.163 8.183 8.193 dd.row_mean &lt;- rowMeans(dd.con, na.rm = TRUE) head(dd.row_mean) ## [1] 8.733 9.184 7.956 8.743 7.786 8.136 "],
["stringr.html", "Chapter 10 文字與字串資料處理 10.1 文字與字串資料基礎 10.2 套件 stringr 10.3 合併文字或字串 str_c() 10.4 取出文字或字串向量中的部分元素 str_sub() 10.5 語言設定地區與文字大小寫排序 10.6 移除空白, 加入空白, 截斷文字 str_trim() 與 str_pad() 10.7 尋找特定形式文字或字串 10.8 群組尋找特定形式的文字與字串 10.9 尋找連續重覆特定形式的文字與字串 10.10 正規表示文字與字串 (萬用字元)", " Chapter 10 文字與字串資料處理 傳統上, 統計人員較少直接處裡文字或字串資料, 多數時候是由資料管理人元處理後, 轉換成數值資料, 然後交由統計人員進行後續分析. 由於大數據時代來臨包含者多樣性的資料型態, 統計人員必須必須直接處裡文字或字串資料的機會也越來越多. {R} 內有許多函數可以處理文字型態的資料物件 或 文字資料 (Character Data), 常用之文字函式有 paste(), substr(), substring(), grep(), gsub(), strsplit() 等. {R} 套件 stringr 有更多處理文字或字串資料函式. 10.1 文字與字串資料基礎 輸入文字遠比數字複雜, 必須考慮大小寫, 空格或 Tab, 單引號或雙引號, 特殊符號與字元等等. {R} 輸入特殊符號的顯示與實際想要輸入的特殊符號有些差別. st1 &lt;- &quot;This is a book&quot; st1 ## [1] &quot;This is a book&quot; st2 &lt;- &#39;To include a double &quot;quote&quot; inside a string, use single quotes&#39; st2 ## [1] &quot;To include a double \\&quot;quote\\&quot; inside a string, use single quotes&quot; st3 &lt;- &quot;To include a single &#39;quote&#39; inside a string, use double quotes&quot; st3 ## [1] &quot;To include a single &#39;quote&#39; inside a string, use double quotes&quot; double_quote &lt;- &quot;\\&quot;&quot; # or &#39;&quot;&#39; double_quote ## [1] &quot;\\&quot;&quot; single_quote &lt;- &#39;\\&#39;&#39; # or &quot;&#39;&quot; single_quote ## [1] &quot;&#39;&quot; 類似情形, 若要輸入反斜線 \\, 則須輸入連續 2 個反斜線: \\\\. backslash &lt;- c(&quot;\\\\&quot;) backslash ## [1] &quot;\\\\&quot; {R} 輸入特殊符號反斜線 \\ 的顯示 \"\\\\\" 與實際想要輸入的單一個反斜線有些差別`. 若要呈現實際想要輸入的特殊符號, 可使用函式 writeLines(). x.char &lt;- c(&quot;\\&quot;&quot;, &quot;\\\\&quot;) x.char ## [1] &quot;\\&quot;&quot; &quot;\\\\&quot; writeLines(x.char) ## &quot; ## \\ 利用指令 ?'\"' 或 ?\"'\" 可以得到特殊符號的輸入方式. \\n newline \\r carriage return \\t tab \\b backspace \\a alert (bell) \\f form feed \\v vertical tab \\\\ backslash \\ \\' ASCII apostrophe ' \\\" ASCII quotation mark \" \\` ASCII grave accent (backtick) ` \\nnn character with given octal code (1, 2 or 3 digits) \\xnn character with given hex code (1 or 2 hex digits) \\unnnn Unicode character with given code (1–4 hex digits) \\Unnnnnnnn Unicode character with given code (1–8 hex digits) x.utf &lt;- &quot;\\u00b5&quot; x.utf ## [1] &quot;μ&quot; 10.2 套件 stringr {R} base 有許多函式處理文字或字串, 但函式的引數並不具有一致性, 容易混淆, 因此 tidyverse 系列的套件 stringr 內的函式都以 str_ 為起始, 例如, str_length() 回傳文字向量內的文字字數. library(stringr) str_length(c(&quot;a&quot;, &quot;Biostatistics&quot;, &quot;Medical Statistics&quot;, &quot;\\&#39;\\b\\t&quot;, NA)) ## [1] 1 13 18 3 NA 10.3 合併文字或字串 str_c() 函式 str_c() 可以合併文字或字串, 類似 {R} base 函式 paste(). 使用引數 sep 設定合併的中間字元. str_c(&quot;medical&quot;, &quot;statistics&quot;) ## [1] &quot;medicalstatistics&quot; str_c(&quot;medical&quot;, &quot;statistics&quot;, sep = &quot; &quot;) ## [1] &quot;medical statistics&quot; str_c(&quot;medical&quot;, &quot;statistics&quot;, sep = &quot;-&quot;) ## [1] &quot;medical-statistics&quot; str_c(&quot;medical&quot;, &quot;statistics&quot;, sep = &quot; + &quot;) ## [1] &quot;medical + statistics&quot; str_c(&quot;|-&quot;, &quot;medical&quot;, &quot;statistics&quot;, &quot;-|&quot;) ## [1] &quot;|-medicalstatistics-|&quot; 若是遇到缺失值 NA, 則仍回傳 NA, 若要改變遇到缺失值 NA, 回傳列印 NA, 可以使用加用函式 str_replace_na(). x.char &lt;- c(&quot;bio&quot;, NA, &quot;statistics&quot;) str_c(&quot;pre-&quot;, x.char, &quot;-end&quot;) ## [1] &quot;pre-bio-end&quot; NA &quot;pre-statistics-end&quot; str_c(&quot;pre-&quot;, str_replace_na(x.char), &quot;-end&quot;) ## [1] &quot;pre-bio-end&quot; &quot;pre-NA-end&quot; &quot;pre-statistics-end&quot; 若要合併 2 個字串向量為單一字串, 可以使用引數 collpse. char.vec &lt;- c(&quot;I&quot;, &quot;love&quot;, &quot;biostatistics&quot;) str_c(char.vec, collapse = &quot;, &quot;) ## [1] &quot;I, love, biostatistics&quot; str_c(char.vec, collapse = &quot;+&quot;) ## [1] &quot;I+love+biostatistics&quot; str_c(char.vec, collapse = &quot; &quot;) ## [1] &quot;I love biostatistics&quot; str_c(char.vec, sep = &quot; &quot;) ## [1] &quot;I&quot; &quot;love&quot; &quot;biostatistics&quot; str_c(&quot;I&quot;, &quot;love&quot;, &quot;biostatistics&quot;, sep = &quot; &quot;) ## [1] &quot;I love biostatistics&quot; 10.4 取出文字或字串向量中的部分元素 str_sub() 函式 str_sub() 可以取出取出文字或字串向量中元素的部分文字. str_sub(string, start = 1L, end = -1L) 引數 start 與 end 分別為向量中元素內文字之起始位置與結束位置. 即使向量長度不足仍會回傳. char.vec &lt;- c(&quot;I&quot;, &quot;love&quot;, &quot;medical&quot;, &quot;statistics&quot;) str_sub(char.vec, start = 1, end = 3) ## [1] &quot;I&quot; &quot;lov&quot; &quot;med&quot; &quot;sta&quot; 10.5 語言設定地區與文字大小寫排序 不同地區的文字, 可能有類似文字, 在大小寫轉換實常會出現轉換錯誤, 若要確保大小寫轉換或排序正確, 套件 stringr 內的函式可改設定 {R} 程式使用文字的地區. 例如, 大小寫轉換函式 str_to_lower(),str_to_upper()或str_to_title()` 的使用. char.vec &lt;- c(&quot;I&quot;, &quot;Love&quot;, &quot;Medical&quot;, &quot;Statistics&quot;) str_to_upper(char.vec) ## [1] &quot;I&quot; &quot;LOVE&quot; &quot;MEDICAL&quot; &quot;STATISTICS&quot; str_to_lower(char.vec) ## [1] &quot;i&quot; &quot;love&quot; &quot;medical&quot; &quot;statistics&quot; str_to_title(str_to_upper(char.vec)) ## [1] &quot;I&quot; &quot;Love&quot; &quot;Medical&quot; &quot;Statistics&quot; str_to_title(str_to_lower(char.vec)) ## [1] &quot;I&quot; &quot;Love&quot; &quot;Medical&quot; &quot;Statistics&quot; {R} base 函式 sort() 與 order() 定 {R} 程式登入使用文字的地區 套件 stringr 內的函式 str_sort() 與 str_order(), 可以使用引數locale` 設定使用文字的地區. veg.vec &lt;- c(&quot;apple&quot;, &quot;eggplant&quot;, &quot;banana&quot;) sort(veg.vec) ## [1] &quot;apple&quot; &quot;banana&quot; &quot;eggplant&quot; order(veg.vec) ## [1] 1 3 2 str_sort(veg.vec, locale = &quot;en&quot;) # English ## [1] &quot;apple&quot; &quot;banana&quot; &quot;eggplant&quot; str_sort(veg.vec, locale = &quot;haw&quot;) # Hawaiian ## [1] &quot;apple&quot; &quot;eggplant&quot; &quot;banana&quot; 10.6 移除空白, 加入空白, 截斷文字 str_trim() 與 str_pad() 套件 stringr 內的函式 str_trim() 與 str_pad() 可以對文字或字串向量內的首尾之空白 (white space) 移除, 或是加入. str_trim(string, side = c(&quot;both&quot;, &quot;left&quot;, &quot;right&quot;)) str_pad(string, width, side = c(&quot;left&quot;, &quot;right&quot;, &quot;both&quot;), pad = &quot; &quot;) str_trunc(string, width, side = c(&quot;right&quot;, &quot;left&quot;, &quot;center&quot;), ellipsis = &quot;...&quot;) 引數 both, left, right 分別處理在首尾二端, 左端, 右端之空白. width 為加入空白後字串的長度, pad 為替代加入空白的文字或符號. veg.vec &lt;- c(&quot;apple &quot;, &quot; eggplant &quot;, &quot; banana&quot;) str_trim(veg.vec, side = c(&quot;both&quot;)) ## [1] &quot;apple&quot; &quot;eggplant&quot; &quot;banana&quot; str_trim(veg.vec, side = c(&quot;left&quot;)) ## [1] &quot;apple &quot; &quot;eggplant &quot; &quot;banana&quot; str_trim(veg.vec, side = c(&quot;right&quot;)) ## [1] &quot;apple&quot; &quot; eggplant&quot; &quot; banana&quot; veg.vec &lt;- c(&quot;apple &quot;, &quot; eggplant &quot;, &quot; banana&quot;) str_pad(&quot;a&quot;, width = 15, side = c(&quot;both&quot;), pad = &quot; &quot;) ## [1] &quot; a &quot; str_pad(&quot;a&quot;, width = 15, side = c(&quot;both&quot;), pad = c(&quot;_&quot;)) ## [1] &quot;_______a_______&quot; str_pad(veg.vec, width = 15, side = c(&quot;both&quot;)) ## [1] &quot; apple &quot; &quot; eggplant &quot; &quot; banana &quot; str_pad(veg.vec, width = 15, side = c(&quot;left&quot;)) ## [1] &quot; apple &quot; &quot; eggplant &quot; &quot; banana&quot; str_pad(veg.vec, width = 15, side = c(&quot;right&quot;)) ## [1] &quot;apple &quot; &quot; eggplant &quot; &quot; banana &quot; str_pad(veg.vec, width = 15, side = c(&quot;both&quot;), pad = c(&quot;_&quot;)) ## [1] &quot;____apple _____&quot; &quot;__ eggplant ___&quot; &quot;____ banana____&quot; char.vec &lt;- c(&quot;I love biostatistics&quot;) str_trunc(char.vec, width = 10, side = c(&quot;center&quot;)) ## [1] &quot;I lo...ics&quot; str_trunc(char.vec, width = 10, side = c(&quot;left&quot;)) ## [1] &quot;...tistics&quot; str_trunc(char.vec, width = 10, side = c(&quot;right&quot;)) ## [1] &quot;I love ...&quot; 10.7 尋找特定形式文字或字串 文字或字串處理中一項重要的工作是尋找特定形式文字或字串 (pattern), 然後進行 detect (偵測), locate (確認位置), extract (取出), match (配對), replace (替代置換) 與 split (分割). 10.7.1 偵測函式 str_detect() 套件 stringr 內的函式 str_detect() 偵測字串向量是否包含特定形式文字, 回傳邏輯向量. 這與 {R} base 函式 grep(pattern, x) 類似. 函式 str_count() 計算字串內配對成功的次數. str_detect(string, pattern, negate = FALSE) str_count(string, pattern = &quot;&quot;) 引數 pattern 定義所要尋找特定形式的文字, 若 negate = TRUE 同時回傳沒有配對成功的邏輯向量. char.vec &lt;- c(&quot;statistics&quot;, &quot;biostatistics&quot;, &quot;probability&quot;, &quot;distribution&quot;) str_detect(char.vec, pattern = &quot;statistics&quot;, negate = FALSE) ## [1] TRUE TRUE FALSE FALSE str_detect(char.vec, pattern = &quot;statistics&quot;, negate = TRUE) ## [1] FALSE FALSE TRUE TRUE str_detect(char.vec, pattern = &quot;ti&quot;, negate = FALSE) ## [1] TRUE TRUE FALSE TRUE str_detect(char.vec, pattern = &quot;function&quot;, negate = FALSE) ## [1] FALSE FALSE FALSE FALSE # str_count(char.vec, pattern = &quot;ti&quot;) ## [1] 2 2 0 1 str_count(char.vec, pattern = &quot;b&quot;) ## [1] 0 1 2 1 10.7.2 確認位置函式 str_detect() 函式 str_locate() 尋找配對成功的字串之第 1 次位置, 回傳矩陣, 包含起始以末端的位置. 這與 {R} base 函式 regexpr() 與 gregexpr() 類似. str_locate(string, pattern) str_locate_all(string, pattern) 另外函式 str_locate_all() 尋找配對成功的字串之所有位置, 回傳列表. char.vec &lt;- c(&quot;statistics&quot;, &quot;biostatistics&quot;, &quot;probability&quot;, &quot;distribution&quot;) str_locate(char.vec, pattern = &quot;ti&quot;) ## start end ## [1,] 4 5 ## [2,] 7 8 ## [3,] NA NA ## [4,] 9 10 str_locate_all(char.vec, pattern = &quot;ti&quot;) ## [[1]] ## start end ## [1,] 4 5 ## [2,] 7 8 ## ## [[2]] ## start end ## [1,] 7 8 ## [2,] 10 11 ## ## [[3]] ## start end ## ## [[4]] ## start end ## [1,] 9 10 10.7.3 確認索引函式 str_subset() 與 str_which() 函式 str_subset() 尋找字串向量內配對成功的之第 1 次的元素內容, 而函式 str_which() 尋找字串向量內配對成功的之第 1 次索引 (index). str_subset(string, pattern, negate = FALSE) str_which(string, pattern, negate = FALSE) 若引數 negate = TRUE 回傳沒有配對成功的元素內容或索引. 函式 str_subset() 與函式 x[str_detect(x, pattern)] 類似功能, 等同於 R base 函式 grep(pattern, x, value = TRUE). 而函式 str_which() 與函式 which(str_detect(x, pattern)) 類似功能, 等同於 R base 函式 grep(pattern, x), 如同函式 str_detect() 同於 R base 函式 grepl(pattern, x). char.vec &lt;- c(&quot;statistics&quot;, &quot;biostatistics&quot;, &quot;probability&quot;, &quot;distribution&quot;) str_subset(char.vec, pattern = &quot;ti&quot;) ## [1] &quot;statistics&quot; &quot;biostatistics&quot; &quot;distribution&quot; str_which(char.vec, pattern = &quot;ti&quot;) ## [1] 1 2 4 10.7.4 取出函式 str_extract() 函式 str_extract() 尋找配對成功的字串之第 1 次位置, 回傳字串向量. str_extract(string, pattern) str_extract_all(string, pattern, simplify = FALSE) 另外函式 str_extract_all() 尋找配對成功的字串之所有位置, 回傳所有字串向量形成列表. 引數 simplify = TRUE 簡化成文字矩陣. char.vec &lt;- c(&quot;statistics&quot;, &quot;biostatistics&quot;, &quot;probability&quot;, &quot;distribution&quot;) str_extract(char.vec, pattern = &quot;ti&quot;) ## [1] &quot;ti&quot; &quot;ti&quot; NA &quot;ti&quot; str_extract_all(char.vec, pattern = &quot;ti&quot;) ## [[1]] ## [1] &quot;ti&quot; &quot;ti&quot; ## ## [[2]] ## [1] &quot;ti&quot; &quot;ti&quot; ## ## [[3]] ## character(0) ## ## [[4]] ## [1] &quot;ti&quot; 10.7.5 配對函式 str_match() 函式 str_match() 使用在群組尋找特定形式文字或字串, 若尋到找配對成功的字串之第 1 次位置, 回傳文字矩陣,第一欄位為完全配對成功的文字, 其餘欄位為群組內個別配對成功的文字. str_match(string, pattern) str_match_all(string, pattern) 另外函式 str_match_all() 尋找配對成功的字串之所有位置. char.vec &lt;- c(&quot;statistics&quot;, &quot;biostatistics&quot;, &quot;probability&quot;, &quot;distribution&quot;) str_match(char.vec, pattern = &quot;(a|ti)&quot;) ## [,1] [,2] ## [1,] &quot;a&quot; &quot;a&quot; ## [2,] &quot;a&quot; &quot;a&quot; ## [3,] &quot;a&quot; &quot;a&quot; ## [4,] &quot;ti&quot; &quot;ti&quot; str_match_all(char.vec, pattern = &quot;(a|ti)&quot;) ## [[1]] ## [,1] [,2] ## [1,] &quot;a&quot; &quot;a&quot; ## [2,] &quot;ti&quot; &quot;ti&quot; ## [3,] &quot;ti&quot; &quot;ti&quot; ## ## [[2]] ## [,1] [,2] ## [1,] &quot;a&quot; &quot;a&quot; ## [2,] &quot;ti&quot; &quot;ti&quot; ## [3,] &quot;ti&quot; &quot;ti&quot; ## ## [[3]] ## [,1] [,2] ## [1,] &quot;a&quot; &quot;a&quot; ## ## [[4]] ## [,1] [,2] ## [1,] &quot;ti&quot; &quot;ti&quot; 10.7.6 替代置換函式 str_replace() 函式 str_match() 使用在群組尋找特定形式文字或字串, 若尋找到配對成功的字串之第 1 次位置, 則使用其他特定字串替代置換. str_replace(string, pattern, replacement) str_replace_all(string, pattern, replacement) 引數 replacement 設定新的替代字串置換原有尋找特定形式文字或字串. 另外函式 str_replace_all() 尋找配對成功的字串之所有位置, 同時使用其他特定字串替代置換. char.vec &lt;- c(&quot;statistics&quot;, &quot;biostatistics&quot;, &quot;probability&quot;, &quot;distribution&quot;) str_replace(char.vec, pattern = &quot;ti&quot;, replacement = &quot;--&quot;) ## [1] &quot;sta--stics&quot; &quot;biosta--stics&quot; &quot;probability&quot; &quot;distribu--on&quot; str_replace_all(char.vec, pattern = &quot;b&quot;, replacement = &quot;+++&quot;) ## [1] &quot;statistics&quot; &quot;+++iostatistics&quot; &quot;pro+++a+++ility&quot; &quot;distri+++ution&quot; 10.7.7 分割函式 str_split() 函式 str_split() 使用在群組尋找特定形式文字或字串, 若尋找到配對成功的字串之第 1 次位置, 則從特定形式文字或字串分割字串向量, 回傳分割結果為列表物件. str_split(string, pattern, n = Inf, simplify = FALSE) str_split_fixed(string, pattern, n) str_split_n(string, pattern, n) 其中引數 n 設定回傳物件的數目, simplify = TRUE 回傳物件簡化成文字矩陣. 另外函式 str_split_fixed() 回傳物件簡化成文字矩陣且欄位 (column) 數目為 n. str_split_n() 回傳物件簡化成文字向量, 長度為 n. char.vec &lt;- c(&quot;a b c&quot;, &quot;d e&quot;, &quot;bio-statistics required-courses&quot;) str_split(char.vec, pattern = &quot; &quot;, n = Inf, simplify = FALSE) ## [[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## [[2]] ## [1] &quot;d&quot; &quot;e&quot; ## ## [[3]] ## [1] &quot;bio-statistics&quot; &quot;required-courses&quot; str_split(char.vec, pattern = &quot; &quot;, n = Inf, simplify = TRUE) ## [,1] [,2] [,3] ## [1,] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## [2,] &quot;d&quot; &quot;e&quot; &quot;&quot; ## [3,] &quot;bio-statistics&quot; &quot;required-courses&quot; &quot;&quot; str_split_fixed(char.vec, pattern = &quot; &quot;, n = 2) ## [,1] [,2] ## [1,] &quot;a&quot; &quot;b c&quot; ## [2,] &quot;d&quot; &quot;e&quot; ## [3,] &quot;bio-statistics&quot; &quot;required-courses&quot; str_split_fixed(char.vec, pattern = &quot;-&quot;, n = 2) ## [,1] [,2] ## [1,] &quot;a b c&quot; &quot;&quot; ## [2,] &quot;d e&quot; &quot;&quot; ## [3,] &quot;bio&quot; &quot;statistics required-courses&quot; 10.8 群組尋找特定形式的文字與字串 有些時候在尋找特定形式的文字與字串, 須要尋找不只一種特定的形式, 此時須藉由 alternate, anchor 與 look around 概念處理. 例如, 同時尋找 b 或 ti, 可以輸入 b|ti. char.vec &lt;- c(&quot;statistics&quot;, &quot;biostatistics&quot;, &quot;probability&quot;, &quot;distribution&quot;) str_replace(char.vec, pattern = &quot;b|ti&quot;, replacement = &quot;--&quot;) ## [1] &quot;sta--stics&quot; &quot;--iostatistics&quot; &quot;pro--ability&quot; &quot;distri--ution&quot; str_replace_all(char.vec, pattern = &quot;b|ti&quot;, replacement = &quot;+++&quot;) ## [1] &quot;sta+++s+++cs&quot; &quot;+++iosta+++s+++cs&quot; &quot;pro+++a+++ility&quot; ## [4] &quot;distri+++u+++on&quot; anchor 起始符號 ^ 可以尋找字串的起始具有特定形式, 尾端符號 $ 可以尋找字串的尾端具有特定形式. 例如, ^b, 尋找字串的起始具有 b, 或 n$, 尋找字串的尾端具 n. char.vec &lt;- c(&quot;statistics&quot;, &quot;biostatistics&quot;, &quot;probability&quot;, &quot;distribution&quot;) str_replace(char.vec, pattern = &quot;^b&quot;, replacement = &quot;--&quot;) ## [1] &quot;statistics&quot; &quot;--iostatistics&quot; &quot;probability&quot; &quot;distribution&quot; str_replace_all(char.vec, pattern = &quot;n$&quot;, replacement = &quot;+++&quot;) ## [1] &quot;statistics&quot; &quot;biostatistics&quot; &quot;probability&quot; &quot;distributio+++&quot; 有些時候需要尋找字串前後具有特定形式的文字與字串, 例如, 尋找在 ti 之前的字元, 在 p 之後的字元等等. 使用小括號 () 代表特定形式的前後順序. 輸入 a(?=c) 表示在 a 之後有 c 字元, 輸入 a(?!c) 表示在 a 之後無 c 字元, 輸入 (?&lt;=b)a 表示在 a 之前有 b 字元, 輸入 (?&lt;!b)a 表示在 a 之前無 b 字元. char.vec &lt;- c(&quot;statistics&quot;, &quot;biostatistics&quot;, &quot;probability&quot;, &quot;distribution&quot;) str_replace(char.vec, pattern = &quot;t(?=i)&quot;, replacement = &quot;--&quot;) ## [1] &quot;sta--istics&quot; &quot;biosta--istics&quot; &quot;probability&quot; &quot;distribu--ion&quot; str_replace(char.vec, pattern = &quot;t(?!i)&quot;, replacement = &quot;--&quot;) ## [1] &quot;s--atistics&quot; &quot;bios--atistics&quot; &quot;probabili--y&quot; &quot;dis--ribution&quot; str_replace(char.vec, pattern = &quot;(?&lt;=i)o&quot;, replacement = &quot;--&quot;) ## [1] &quot;statistics&quot; &quot;bi--statistics&quot; &quot;probability&quot; &quot;distributi--n&quot; str_replace_all(char.vec, pattern = &quot;(?&lt;=t)i&quot;, replacement = &quot;--&quot;) ## [1] &quot;stat--st--cs&quot; &quot;biostat--st--cs&quot; &quot;probability&quot; &quot;distribut--on&quot; str_replace(char.vec, pattern = &quot;(?&lt;!t)i&quot;, replacement = &quot;--&quot;) ## [1] &quot;statistics&quot; &quot;b--ostatistics&quot; &quot;probab--lity&quot; &quot;d--stribution&quot; str_replace_all(char.vec, pattern = &quot;(?&lt;!t)i&quot;, replacement = &quot;--&quot;) ## [1] &quot;statistics&quot; &quot;b--ostatistics&quot; &quot;probab--l--ty&quot; &quot;d--str--bution&quot; 10.9 尋找連續重覆特定形式的文字與字串 一個字串可能不只一個特定形式的文字與字串連續重覆出現, 套件 stringr 尋找特定形式的文字與字串, 可以合併考量連續重覆出現次數. 其中 {} 內不可有空格. stringr 在群組 () 之後加上 \\\\1, \\\\2, … 等, 如同 可以設定尋找連續重覆出現次數. stringr 輸入 意義 a? zero or one a* zero or more a+ one or more a{n} exactly n a{n, } n or more a{n, m} between n and m x.vec &lt;- c(&quot;.a.aa.aaa.aaaa&quot;) str_replace(x.vec, pattern = &quot;a?&quot;, replacement = &quot;-&quot;) ## [1] &quot;-.a.aa.aaa.aaaa&quot; str_replace(x.vec, pattern = &quot;a*&quot;, replacement = &quot;-&quot;) ## [1] &quot;-.a.aa.aaa.aaaa&quot; str_replace(x.vec, pattern = &quot;a+&quot;, replacement = &quot;-&quot;) ## [1] &quot;.-.aa.aaa.aaaa&quot; str_replace(x.vec, pattern = &quot;a{2}&quot;, replacement = &quot;-&quot;) ## [1] &quot;.a.-.aaa.aaaa&quot; str_replace(x.vec, pattern = &quot;a{2,}&quot;, replacement = &quot;-&quot;) ## [1] &quot;.a.-.aaa.aaaa&quot; str_replace(x.vec, pattern = &quot;a{2,3}&quot;, replacement = &quot;-&quot;) ## [1] &quot;.a.-.aaa.aaaa&quot; char.vec &lt;- c(&quot;statistics&quot;, &quot;biostatistics&quot;, &quot;probability&quot;, &quot;distribution&quot;) str_replace(char.vec, pattern = &quot;i?&quot;, replacement = &quot;-&quot;) ## [1] &quot;-statistics&quot; &quot;-biostatistics&quot; &quot;-probability&quot; &quot;-distribution&quot; str_replace(char.vec, pattern = &quot;i*&quot;, replacement = &quot;-&quot;) ## [1] &quot;-statistics&quot; &quot;-biostatistics&quot; &quot;-probability&quot; &quot;-distribution&quot; str_replace(char.vec, pattern = &quot;i+&quot;, replacement = &quot;-&quot;) ## [1] &quot;stat-stics&quot; &quot;b-ostatistics&quot; &quot;probab-lity&quot; &quot;d-stribution&quot; str_replace(char.vec, pattern = &quot;i{2}&quot;, replacement = &quot;-&quot;) ## [1] &quot;statistics&quot; &quot;biostatistics&quot; &quot;probability&quot; &quot;distribution&quot; str_replace(char.vec, pattern = &quot;i{2}&quot;, replacement = &quot;-&quot;) ## [1] &quot;statistics&quot; &quot;biostatistics&quot; &quot;probability&quot; &quot;distribution&quot; str_replace(char.vec, pattern = &quot;i{2,3}&quot;, replacement = &quot;-&quot;) ## [1] &quot;statistics&quot; &quot;biostatistics&quot; &quot;probability&quot; &quot;distribution&quot; 10.10 正規表示文字與字串 (萬用字元) {R} 尋找特定形式的文字與字串, 可以使用程式語言通用的正規表示 (regular expression), 在使用套件 stringr 輸入時有些差異, 以下表摘要說明. stringr 輸入 正規表示 真實的文字與字串 \\\\. \\. . \\\\! \\! ! \\\\? \\? ? \\\\\\\\ \\\\ \\ \\\\( \\( ( \\\\) \\) ) \\\\{ \\{ { \\\\} \\} } \\\\n \\n new line (return) \\t \\t tab \\\\s \\s any whitespace (\\S for non-whitespaces) \\\\d \\d any digit (\\D for non-digits) \\\\w \\w any word character (\\W for non-word chars) \\\\b \\b word boundaries \\\\k \\k k = integer, repeated number [:digit:] digits [:alpha:] letters [:lower:] lowercase letters [:upper:] uppercase letters [:alnum:] letters and numbers [:punct:] punctuation [:graph:] letters, numbers, and punctuation [:space:] space characters (i.e. \\s) [:blank:] space and tab (but not new line) . every character except a new line Table 3: 正規表示文字與字串 (萬用字元) char.vec &lt;- c(&quot;statistics.123&quot;, &quot;biostatistics.a.b.c&quot;, &quot;probability.a.c&quot;, &quot;distribution.a c&quot;) str_replace(char.vec, pattern = &quot;.i.&quot;, replacement = &quot;-&quot;) ## [1] &quot;sta-tics.123&quot; &quot;-statistics.a.b.c&quot; &quot;proba-ity.a.c&quot; ## [4] &quot;-tribution.a c&quot; str_replace_all(char.vec, pattern = &quot;.i.&quot;, replacement = &quot;-&quot;) ## [1] &quot;sta--s.123&quot; &quot;-sta--s.a.b.c&quot; &quot;proba-ity.a.c&quot; &quot;-t-u-n.a c&quot; str_replace(char.vec, pattern = &quot;y\\\\.a&quot;, replacement = &quot;-&quot;) ## [1] &quot;statistics.123&quot; &quot;biostatistics.a.b.c&quot; &quot;probabilit-.c&quot; ## [4] &quot;distribution.a c&quot; str_replace(char.vec, pattern = &quot;a[.]c&quot;, replacement = &quot;-&quot;) ## [1] &quot;statistics.123&quot; &quot;biostatistics.a.b.c&quot; &quot;probability.-&quot; ## [4] &quot;distribution.a c&quot; str_replace(char.vec, pattern = &quot;a[ ]&quot;, replacement = &quot;-&quot;) ## [1] &quot;statistics.123&quot; &quot;biostatistics.a.b.c&quot; &quot;probability.a.c&quot; ## [4] &quot;distribution.-c&quot; str_replace(char.vec, pattern = &quot;b[ab]+&quot;, replacement = &quot;-&quot;) ## [1] &quot;statistics.123&quot; &quot;biostatistics.a.b.c&quot; &quot;pro-ility.a.c&quot; ## [4] &quot;distribution.a c&quot; y.vec &lt;- c(&quot;set&quot;, &quot;sat&quot;, &quot;sit&quot;, &quot;sout&quot;) str_replace(y.vec, pattern = &quot;s(a|i)t&quot;, replacement = &quot;-&quot;) ## [1] &quot;set&quot; &quot;-&quot; &quot;-&quot; &quot;sout&quot; fruits.vec &lt;- c(&quot;banana&quot;, &quot;coconut&quot;, &quot;cucumber&quot;, &quot;jujube&quot;, &quot;papaya&quot;, &quot;berry&quot;) str_replace(fruits.vec, pattern = &quot;(..)\\\\1&quot;, replacement = &quot;-&quot;) ## [1] &quot;b-a&quot; &quot;-nut&quot; &quot;-mber&quot; &quot;-be&quot; &quot;-ya&quot; &quot;berry&quot; str_replace(fruits.vec, pattern = &quot;(.)(.)\\\\2\\\\1&quot;, replacement = &quot;-&quot;) ## [1] &quot;banana&quot; &quot;coconut&quot; &quot;cucumber&quot; &quot;jujube&quot; &quot;papaya&quot; &quot;berry&quot; z.vec &lt;- c(&quot;3 house&quot;, &quot;4 cars&quot;, &quot;5 dogs&quot;) str_replace_all(z.vec, c(&quot;3&quot; = &quot;three&quot;, &quot;4&quot; = &quot;four&quot;, &quot;5&quot; = &quot;five&quot;)) ## [1] &quot;three house&quot; &quot;four cars&quot; &quot;five dogs&quot; sent.vec &lt;- sentences[1:5] sent.vec ## [1] &quot;The birch canoe slid on the smooth planks.&quot; ## [2] &quot;Glue the sheet to the dark blue background.&quot; ## [3] &quot;It&#39;s easy to tell the depth of a well.&quot; ## [4] &quot;These days a chicken leg is a rare dish.&quot; ## [5] &quot;Rice is often served in round bowls.&quot; sent.vec %&gt;% str_subset(pattern = &quot;(a|the) ([^ ]+)&quot;) %&gt;% str_extract(pattern = &quot;(a|the) ([^ ]+)&quot;) ## [1] &quot;the smooth&quot; &quot;the sheet&quot; &quot;the depth&quot; &quot;a chicken&quot; sent.vec %&gt;% str_subset(pattern = &quot;(a|the) ([^ ]+)&quot;) %&gt;% str_match(pattern = &quot;(a|the) ([^ ]+)&quot;) ## [,1] [,2] [,3] ## [1,] &quot;the smooth&quot; &quot;the&quot; &quot;smooth&quot; ## [2,] &quot;the sheet&quot; &quot;the&quot; &quot;sheet&quot; ## [3,] &quot;the depth&quot; &quot;the&quot; &quot;depth&quot; ## [4,] &quot;a chicken&quot; &quot;a&quot; &quot;chicken&quot; sent.vec %&gt;% str_replace(&quot;([^ ]+) ([^ ]+) ([^ ]+)&quot;, &quot;\\\\1 \\\\3 \\\\2&quot;) ## [1] &quot;The canoe birch slid on the smooth planks.&quot; ## [2] &quot;Glue sheet the to the dark blue background.&quot; ## [3] &quot;It&#39;s to easy tell the depth of a well.&quot; ## [4] &quot;These a days chicken leg is a rare dish.&quot; ## [5] &quot;Rice often is served in round bowls.&quot; "],
["applications.html", "Chapter 11 Applications 11.1 Example one 11.2 Example two", " Chapter 11 Applications Some significant applications are demonstrated in this chapter. 11.1 Example one 11.2 Example two "],
["final-words.html", "Chapter 12 Final Words", " Chapter 12 Final Words We have finished a nice book. "],
["temp.html", "Chapter 13 Temp", " Chapter 13 Temp We have finished a nice book. "],
["references.html", "References", " References Xie, Yihui. 2015. Dynamic Documents with R and Knitr. 2nd ed. Boca Raton, Florida: Chapman; Hall/CRC. http://yihui.org/knitr/. ———. 2020. Bookdown: Authoring Books and Technical Documents with R Markdown. https://CRAN.R-project.org/package=bookdown. "]
]
